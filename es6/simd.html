<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ES6SIMD - ES6教程 - V站前端教程</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="../assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="../assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="ES6SIMD"><link rel="apple-touch-icon" href="../assets/icons/logo.png"><link rel="icon" type="image/png" href="../assets/icons/logo.png"><style>.nav-item-active{background-color: #fff;color:#9cba39}
      a{color:#399ab2}
      a:hover{color:#9cba39}
      .breadcrumb a{color:#399ab2}
      .breadcrumb a:hover{color:#9cba39}
      .navbar.is-light .navbar-end .navbar-link, .navbar.is-light .navbar-end>.navbar-item, 
      .navbar.is-light .navbar-start>.navbar-item:hover{color:#9cba39}
      .navbar-link, a.navbar-item:hover{color:#9cba39}

      .panel-info .panel-block .menu-list a.is-active, .panel-menu .panel-block .menu-list a.is-active {
        color: #fff;
        background-color: #399ab2;
      }
      .menu-list>li{background:#F9F9F9;border-bottom: 1px solid #ededed;} 
      .panel-info .panel-block .menu, .panel-menu .panel-block .menu{padding:0 5px}</style></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container" style="max-width:1230px;"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">V站 / ViJian.com</a></div><div class="navbar-menu" id="navMenu"><div class="navbar-start"><div class="navbar-item"><a class="navbar-item" href="/">首页</a></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link nav-item-active is-hidden-touch">教程</a><div class="navbar-dropdown"><a class="navbar-item" href="/html/intro.html">HTML 教程</a> <a class="navbar-item" href="/es6/intro.html">ES6 教程</a> <a class="navbar-item" href="/typescript/intro.html">TypeScript 教程</a><!--   <a class="navbar-item" href="/webapi/intro.html">Web API 教程</a>
             <a class="navbar-item" href="/css/intro.html">CSS 教程</a>
        <a class="navbar-item" href="/javascript/intro.html">JavaScript 教程</a> --></div></div></div><div class="navbar-end"></div></div></div></nav><section class="section main article" style="padding-top: 20px;"><div class="container" style="max-width:1260px;"><div class="columns"><div class="column" style="flex:none;width:16%"><nav class="panel-menu" style="border: 1px solid #ededed;"><p class="panel-heading" style="font-size: 1.0em;border-radius:0px;padding: 0.5em 0em;text-align: center;"><i class="fa fa-book" aria-hidden="true"></i> ES6教程</p><div class="panel-block" style="padding: 5px 0px;"><aside class="menu"><ul class="menu-list"><li><a href="../es6/intro.html">&nbsp; <span class="menu-list-title" style="width:100%">简介</span></a></li><li><a href="../es6/let.html">&nbsp; <span class="menu-list-title" style="width:100%">let 和 const 命令</span></a></li><li><a href="../es6/destructuring.html">&nbsp; <span class="menu-list-title" style="width:100%">变量的解构赋值</span></a></li><li><a href="../es6/string.html">&nbsp; <span class="menu-list-title" style="width:100%">字符串的扩展</span></a></li><li><a href="../es6/string-methods.html">&nbsp; <span class="menu-list-title" style="width:100%">字符串的新增方法</span></a></li><li><a href="../es6/regex.html">&nbsp; <span class="menu-list-title" style="width:100%">正则的扩展</span></a></li><li><a href="../es6/number.html">&nbsp; <span class="menu-list-title" style="width:100%">数值的扩展</span></a></li><li><a href="../es6/function.html">&nbsp; <span class="menu-list-title" style="width:100%">函数的扩展</span></a></li><li><a href="../es6/array.html">&nbsp; <span class="menu-list-title" style="width:100%">数组的扩展</span></a></li><li><a href="../es6/object.html">&nbsp; <span class="menu-list-title" style="width:100%">对象的扩展</span></a></li><li><a href="../es6/object-methods.html">&nbsp; <span class="menu-list-title" style="width:100%">对象的新增方法</span></a></li><li><a href="../es6/operator.html">&nbsp; <span class="menu-list-title" style="width:100%">运算符的扩展</span></a></li><li><a href="../es6/symbol.html">&nbsp; <span class="menu-list-title" style="width:100%">Symbol</span></a></li><li><a href="../es6/set-map.html">&nbsp; <span class="menu-list-title" style="width:100%">Set 和 Map 数据结构</span></a></li><li><a href="../es6/proxy.html">&nbsp; <span class="menu-list-title" style="width:100%">Proxy</span></a></li><li><a href="../es6/reflect.html">&nbsp; <span class="menu-list-title" style="width:100%">Reflect</span></a></li><li><a href="../es6/promise.html">&nbsp; <span class="menu-list-title" style="width:100%">Promise 对象</span></a></li><li><a href="../es6/iterator.html">&nbsp; <span class="menu-list-title" style="width:100%">Iterator 和 for...of 循环</span></a></li><li><a href="../es6/generator.html">&nbsp; <span class="menu-list-title" style="width:100%">Generator 函数的语法</span></a></li><li><a href="../es6/generator-async.html">&nbsp; <span class="menu-list-title" style="width:100%">Generator 函数的异步应用</span></a></li><li><a href="../es6/async.html">&nbsp; <span class="menu-list-title" style="width:100%">async 函数</span></a></li><li><a href="../es6/class.html">&nbsp; <span class="menu-list-title" style="width:100%">Class 的基本语法</span></a></li><li><a href="../es6/class-extends.html">&nbsp; <span class="menu-list-title" style="width:100%">Class 的继承</span></a></li><li><a href="../es6/module.html">&nbsp; <span class="menu-list-title" style="width:100%">Module 的语法</span></a></li><li><a href="../es6/module-loader.html">&nbsp; <span class="menu-list-title" style="width:100%">Module 的加载实现</span></a></li><li><a href="../es6/style.html">&nbsp; <span class="menu-list-title" style="width:100%">编程风格</span></a></li><li><a href="../es6/spec.html">&nbsp; <span class="menu-list-title" style="width:100%">读懂 ECMAScript 规格</span></a></li><li><a href="../es6/async-iterator.html">&nbsp; <span class="menu-list-title" style="width:100%">异步遍历器</span></a></li><li><a href="../es6/arraybuffer.html">&nbsp; <span class="menu-list-title" style="width:100%">ArrayBuffer</span></a></li><li><a href="../es6/proposals.html">&nbsp; <span class="menu-list-title" style="width:100%">最新提案</span></a></li><li><a href="../es6/decorator.html">&nbsp; <span class="menu-list-title" style="width:100%">装饰器</span></a></li><li><a href="../es6/mixin.html">&nbsp; <span class="menu-list-title" style="width:100%">Mixin</span></a></li><li><a href="../es6/fp.html">&nbsp; <span class="menu-list-title" style="width:100%">函数式编程</span></a></li><li><a href="../es6/simd.html" class="is-active">&nbsp; <span class="menu-list-title" style="width:100%">SIMD</span></a></li><li><a href="../es6/reference.html">&nbsp; <span class="menu-list-title" style="width:100%">参考链接</span></a></li></ul></aside></div></nav></div><div class="column" style="flex:none;width:68%"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="../"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;V站</a></li><li><a href="../es6/simd.html/intro.html">ES6教程</a></li><li><a href="../es6/simd.html">ES6 SIMD</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../es6/fp.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 函数式编程</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../es6/reference.html">参考链接 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">ES6 SIMD</h1><div class="page-meta"><p>V站（ViJian.com）</p></div><h2 id="概述">概述 <a class="markdownIt-Anchor" href="#概述">#</a></h2><p>SIMD（发音<code>/sim-dee/</code>）是“Single Instruction/Multiple Data”的缩写，意为“单指令，多数据”。它是 JavaScript 操作 CPU 对应指令的接口，你可以看做这是一种不同的运算执行模式。与它相对的是 SISD（“Single Instruction/Single Data”），即“单指令，单数据”。</p><p>SIMD 的含义是使用一个指令，完成多个数据的运算；SISD 的含义是使用一个指令，完成单个数据的运算，这是 JavaScript 的默认运算模式。显而易见，SIMD 的执行效率要高于 SISD，所以被广泛用于 3D 图形运算、物理模拟等运算量超大的项目之中。</p><p>为了理解 SIMD，请看下面的例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>];
<span class="hljs-keyword">var</span> b = [<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>];
<span class="hljs-keyword">var</span> c = [];

c[<span class="hljs-number">0</span>] = a[<span class="hljs-number">0</span>] + b[<span class="hljs-number">0</span>];
c[<span class="hljs-number">1</span>] = a[<span class="hljs-number">1</span>] + b[<span class="hljs-number">1</span>];
c[<span class="hljs-number">2</span>] = a[<span class="hljs-number">2</span>] + b[<span class="hljs-number">2</span>];
c[<span class="hljs-number">3</span>] = a[<span class="hljs-number">3</span>] + b[<span class="hljs-number">3</span>];
c <span class="hljs-comment">// Array[6, 8, 10, 12]</span>
</code></pre><p>上面代码中，数组<code>a</code>和<code>b</code>的对应成员相加，结果放入数组<code>c</code>。它的运算模式是依次处理每个数组成员，一共有四个数组成员，所以需要运算 4 次。</p><p>如果采用 SIMD 模式，只要运算一次就够了。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);
<span class="hljs-keyword">var</span> c = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">add</span>(a, b); <span class="hljs-comment">// Float32x4[6, 8, 10, 12]</span>
</code></pre><p>上面代码之中，数组<code>a</code>和<code>b</code>的四个成员的各自相加，只用一条指令就完成了。因此，速度比上一种写法提高了 4 倍。</p><p>一次 SIMD 运算，可以处理多个数据，这些数据被称为“通道”（lane）。上面代码中，一次运算了四个数据，因此就是四个通道。</p><p>SIMD 通常用于矢量运算。</p><pre class="hljs"><code>v + w = 〈v1, …, vn〉+ 〈w1, …, wn〉
      = 〈v1+w1, …, vn+wn〉
</code></pre><p>上面代码中，<code>v</code>和<code>w</code>是两个多元矢量。它们的加运算，在 SIMD 下是一个指令、而不是 n 个指令完成的，这就大大提高了效率。这对于 3D 动画、图像处理、信号处理、数值处理、加密等运算是非常重要的。比如，Canvas 的<code>getImageData()</code>会将图像文件读成一个二进制数组，SIMD 就很适合对于这种数组的处理。</p><p>总的来说，SIMD 是数据并行处理（parallelism）的一种手段，可以加速一些运算密集型操作的速度。将来与 WebAssembly 结合以后，可以让 JavaScript 达到二进制代码的运行速度。</p><h2 id="数据类型">数据类型 <a class="markdownIt-Anchor" href="#数据类型">#</a></h2><p>SIMD 提供 12 种数据类型，总长度都是 128 个二进制位。</p><ul><li>Float32x4：四个 32 位浮点数</li><li>Float64x2：两个 64 位浮点数</li><li>Int32x4：四个 32 位整数</li><li>Int16x8：八个 16 位整数</li><li>Int8x16：十六个 8 位整数</li><li>Uint32x4：四个无符号的 32 位整数</li><li>Uint16x8：八个无符号的 16 位整数</li><li>Uint8x16：十六个无符号的 8 位整数</li><li>Bool32x4：四个 32 位布尔值</li><li>Bool16x8：八个 16 位布尔值</li><li>Bool8x16：十六个 8 位布尔值</li><li>Bool64x2：两个 64 位布尔值</li></ul><p>每种数据类型被<code>x</code>符号分隔成两部分，后面的部分表示通道数，前面的部分表示每个通道的宽度和类型。比如，<code>Float32x4</code>就表示这个值有 4 个通道，每个通道是一个 32 位浮点数。</p><p>每个通道之中，可以放置四种数据。</p><ul><li>浮点数（float，比如 1.0）</li><li>带符号的整数（Int，比如-1）</li><li>无符号的整数（Uint，比如 1）</li><li>布尔值（Bool，包含<code>true</code>和<code>false</code>两种值）</li></ul><p>每种 SIMD 的数据类型都是一个函数方法，可以传入参数，生成对应的值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);
</code></pre><p>上面代码中，变量<code>a</code>就是一个 128 位、包含四个 32 位浮点数（即四个通道）的值。</p><p>注意，这些数据类型方法都不是构造函数，前面不能加<code>new</code>，否则会报错。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> v = <span class="hljs-keyword">new</span> <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// TypeError: SIMD.Float32x4 is not a constructor</span>
</code></pre><h2 id="静态方法数学运算">静态方法：数学运算 <a class="markdownIt-Anchor" href="#静态方法数学运算">#</a></h2><p>每种数据类型都有一系列运算符，支持基本的数学运算。</p><h3 id="simdtypeabssimdtypeneg">SIMD.%type%.abs()，SIMD.%type%.neg() <a class="markdownIt-Anchor" href="#simdtypeabssimdtypeneg">#</a></h3><p><code>abs</code>方法接受一个 SIMD 值作为参数，将它的每个通道都转成绝对值，作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-title class_">NaN</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">abs</span>(a)
<span class="hljs-comment">// Float32x4[1, 2, 0, NaN]</span>
</code></pre><p><code>neg</code>方法接受一个 SIMD 值作为参数，将它的每个通道都转成负值，作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">0</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">neg</span>(a)
<span class="hljs-comment">// Float32x4[1, 2, -3, -0]</span>

<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float64</span>x2(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">Infinity</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float64x2</span>.<span class="hljs-title function_">neg</span>(b)
<span class="hljs-comment">// Float64x2[NaN, -Infinity]</span>
</code></pre><h3 id="simdtypeaddsimdtypeaddsaturate">SIMD.%type%.add()，SIMD.%type%.addSaturate() <a class="markdownIt-Anchor" href="#simdtypeaddsimdtypeaddsaturate">#</a></h3><p><code>add</code>方法接受两个 SIMD 值作为参数，将它们的每个通道相加，作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">5.0</span>, <span class="hljs-number">10.0</span>, <span class="hljs-number">15.0</span>, <span class="hljs-number">20.0</span>);
<span class="hljs-keyword">var</span> c = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">add</span>(a, b);
</code></pre><p>上面代码中，经过加法运算，新的 SIMD 值为<code>(6.0, 12.0, 18.0. 24.0)</code>。</p><p><code>addSaturate</code>方法跟<code>add</code>方法的作用相同，都是两个通道相加，但是溢出的处理不一致。对于<code>add</code>方法，如果两个值相加发生溢出，溢出的二进制位会被丢弃; <code>addSaturate</code>方法则是返回该数据类型的最大值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Uint16</span>x8(<span class="hljs-number">65533</span>, <span class="hljs-number">65534</span>, <span class="hljs-number">65535</span>, <span class="hljs-number">65535</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Uint16</span>x8(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Uint16x8</span>.<span class="hljs-title function_">addSaturate</span>(a, b);
<span class="hljs-comment">// Uint16x8[65534, 65535, 65535, 65535, 2, 2, 2, 2]</span>

<span class="hljs-keyword">var</span> c = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int16</span>x8(<span class="hljs-number">32765</span>, <span class="hljs-number">32766</span>, <span class="hljs-number">32767</span>, <span class="hljs-number">32767</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> d = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int16</span>x8(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int16x8</span>.<span class="hljs-title function_">addSaturate</span>(c, d);
<span class="hljs-comment">// Int16x8[32766, 32767, 32767, 32767, 2, 2, 2, 2]</span>
</code></pre><p>上面代码中，<code>Uint16</code>的最大值是 65535，<code>Int16</code>的最大值是 32767。一旦发生溢出，就返回这两个值。</p><p>注意，<code>Uint32x4</code>和<code>Int32x4</code>这两种数据类型没有<code>addSaturate</code>方法。</p><h3 id="simdtypesubsimdtypesubsaturate">SIMD.%type%.sub()，SIMD.%type%.subSaturate() <a class="markdownIt-Anchor" href="#simdtypesubsimdtypesubsaturate">#</a></h3><p><code>sub</code>方法接受两个 SIMD 值作为参数，将它们的每个通道相减，作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">sub</span>(a, b)
<span class="hljs-comment">// Float32x4[-4, -5, 0, 1]</span>
</code></pre><p><code>subSaturate</code>方法跟<code>sub</code>方法的作用相同，都是两个通道相减，但是溢出的处理不一致。对于<code>sub</code>方法，如果两个值相减发生溢出，溢出的二进制位会被丢弃; <code>subSaturate</code>方法则是返回该数据类型的最小值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Uint16</span>x8(<span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Uint16</span>x8(<span class="hljs-number">10</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Uint16x8</span>.<span class="hljs-title function_">subSaturate</span>(a, b)
<span class="hljs-comment">// Uint16x8[0, 0, 0, 0, 0, 0, 0, 0]</span>

<span class="hljs-keyword">var</span> c = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int16</span>x8(-<span class="hljs-number">100</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-keyword">var</span> d = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int16</span>x8(<span class="hljs-number">32767</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int16x8</span>.<span class="hljs-title function_">subSaturate</span>(c, d)
<span class="hljs-comment">// Int16x8[-32768, 0, 0, 0, 0, 0, 0, 0, 0]</span>
</code></pre><p>上面代码中，<code>Uint16</code>的最小值是<code>0</code>，<code>Int16</code>的最小值是<code>-32678</code>。一旦运算发生溢出，就返回最小值。</p><h3 id="simdtypemulsimdtypedivsimdtypesqrt">SIMD.%type%.mul()，SIMD.%type%.div()，SIMD.%type%.sqrt() <a class="markdownIt-Anchor" href="#simdtypemulsimdtypedivsimdtypesqrt">#</a></h3><p><code>mul</code>方法接受两个 SIMD 值作为参数，将它们的每个通道相乘，作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">mul</span>(a, b)
<span class="hljs-comment">// Float32x4[-3, -6, 9, 12]</span>
</code></pre><p><code>div</code>方法接受两个 SIMD 值作为参数，将它们的每个通道相除，作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">div</span>(a, b)
<span class="hljs-comment">// Float32x4[0.5, 0.5, 0.5, 0.5]</span>
</code></pre><p><code>sqrt</code>方法接受一个 SIMD 值作为参数，求出每个通道的平方根，作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float64</span>x2(<span class="hljs-number">4</span>, <span class="hljs-number">8</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float64x2</span>.<span class="hljs-title function_">sqrt</span>(b)
<span class="hljs-comment">// Float64x2[2, 2.8284271247461903]</span>
</code></pre><h3 id="simdfloattypereciprocalapproximationsimdtypereciprocalsqrtapproximation">SIMD.%FloatType%.reciprocalApproximation()，SIMD.%type%.reciprocalSqrtApproximation() <a class="markdownIt-Anchor" href="#simdfloattypereciprocalapproximationsimdtypereciprocalsqrtapproximation">#</a></h3><p><code>reciprocalApproximation</code>方法接受一个 SIMD 值作为参数，求出每个通道的倒数（<code>1 / x</code>），作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">reciprocalApproximation</span>(a);
<span class="hljs-comment">// Float32x4[1, 0.5, 0.3333333432674408, 0.25]</span>
</code></pre><p><code>reciprocalSqrtApproximation</code>方法接受一个 SIMD 值作为参数，求出每个通道的平方根的倒数（<code>1 / (x^0.5)</code>），作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">reciprocalSqrtApproximation</span>(a)
<span class="hljs-comment">// Float32x4[1, 0.7071067690849304, 0.5773502588272095, 0.5]</span>
</code></pre><p>注意，只有浮点数的数据类型才有这两个方法。</p><h3 id="simdintegertypeshiftleftbyscalar">SIMD.%IntegerType%.shiftLeftByScalar() <a class="markdownIt-Anchor" href="#simdintegertypeshiftleftbyscalar">#</a></h3><p><code>shiftLeftByScalar</code>方法接受一个 SIMD 值作为参数，然后将每个通道的值左移指定的位数，作为一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">shiftLeftByScalar</span>(a, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Int32x4[2, 4, 8, 16]</span>
</code></pre><p>如果左移后，新的值超出了当前数据类型的位数，溢出的部分会被丢弃。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> ix4 = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-keyword">var</span> jx4 = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">shiftLeftByScalar</span>(ix4, <span class="hljs-number">32</span>);
<span class="hljs-comment">// Int32x4[0, 0, 0, 0]</span>
</code></pre><p>注意，只有整数的数据类型才有这个方法。</p><h3 id="simdintegertypeshiftrightbyscalar">SIMD.%IntegerType%.shiftRightByScalar() <a class="markdownIt-Anchor" href="#simdintegertypeshiftrightbyscalar">#</a></h3><p><code>shiftRightByScalar</code>方法接受一个 SIMD 值作为参数，然后将每个通道的值右移指定的位数，返回一个新的 SIMD 值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">8</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">shiftRightByScalar</span>(a, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Int32x4[0, 1, 2, -4]</span>
</code></pre><p>如果原来通道的值是带符号的值，则符号位保持不变，不受右移影响。如果是不带符号位的值，则右移后头部会补<code>0</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Uint32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, -<span class="hljs-number">8</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Uint32x4</span>.<span class="hljs-title function_">shiftRightByScalar</span>(a, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Uint32x4[0, 1, 2, 2147483644]</span>
</code></pre><p>上面代码中，<code>-8</code>右移一位变成了<code>2147483644</code>，是因为对于 32 位无符号整数来说，<code>-8</code>的二进制形式是<code>11111111111111111111111111111000</code>，右移一位就变成了<code>01111111111111111111111111111100</code>，相当于<code>2147483644</code>。</p><p>注意，只有整数的数据类型才有这个方法。</p><h2 id="静态方法通道处理">静态方法：通道处理 <a class="markdownIt-Anchor" href="#静态方法通道处理">#</a></h2><h3 id="simdtypecheck">SIMD.%type%.check() <a class="markdownIt-Anchor" href="#simdtypecheck">#</a></h3><p><code>check</code>方法用于检查一个值是否为当前类型的 SIMD 值。如果是的，就返回这个值，否则就报错。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>);

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">check</span>(a);
<span class="hljs-comment">// Float32x4[1, 2, 3, 9]</span>

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">check</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>]) <span class="hljs-comment">// 报错</span>
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">check</span>(a) <span class="hljs-comment">// 报错</span>
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">check</span>(<span class="hljs-string">&#x27;hello world&#x27;</span>) <span class="hljs-comment">// 报错</span>
</code></pre><h3 id="simdtypeextractlanesimdtypereplacelane">SIMD.%type%.extractLane()，SIMD.%type%.replaceLane() <a class="markdownIt-Anchor" href="#simdtypeextractlanesimdtypereplacelane">#</a></h3><p><code>extractLane</code>方法用于返回给定通道的值。它接受两个参数，分别是 SIMD 值和通道编号。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> t = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">extractLane</span>(t, <span class="hljs-number">2</span>) <span class="hljs-comment">// 3</span>
</code></pre><p><code>replaceLane</code>方法用于替换指定通道的值，并返回一个新的 SIMD 值。它接受三个参数，分别是原来的 SIMD 值、通道编号和新的通道值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> t = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">replaceLane</span>(t, <span class="hljs-number">2</span>, <span class="hljs-number">42</span>)
<span class="hljs-comment">// Float32x4[1, 2, 42, 4]</span>
</code></pre><h3 id="simdtypeload">SIMD.%type%.load() <a class="markdownIt-Anchor" href="#simdtypeload">#</a></h3><p><code>load</code>方法用于从二进制数组读入数据，生成一个新的 SIMD 值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">load</span>(a, <span class="hljs-number">0</span>);
<span class="hljs-comment">// Int32x4[1, 2, 3, 4]</span>

<span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">load</span>(a, <span class="hljs-number">2</span>);
<span class="hljs-comment">// Int32x4[3, 4, 5, 6]</span>
</code></pre><p><code>load</code>方法接受两个参数：一个二进制数组和开始读取的位置（从 0 开始）。如果位置不合法（比如<code>-1</code>或者超出二进制数组的大小），就会抛出一个错误。</p><p>这个方法还有三个变种<code>load1()</code>、<code>load2()</code>、<code>load3()</code>，表示从指定位置开始，只加载一个通道、二个通道、三个通道的值。</p><pre class="hljs"><code><span class="hljs-comment">// 格式</span>
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">load</span>(tarray, index)
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">load1</span>(tarray, index)
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">load2</span>(tarray, index)
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">load3</span>(tarray, index)

<span class="hljs-comment">// 实例</span>
<span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>([<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>]);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">load1</span>(a, <span class="hljs-number">0</span>);
<span class="hljs-comment">// Int32x4[1, 0, 0, 0]</span>
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">load2</span>(a, <span class="hljs-number">0</span>);
<span class="hljs-comment">// Int32x4[1, 2, 0, 0]</span>
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">load3</span>(a, <span class="hljs-number">0</span>);
<span class="hljs-comment">// Int32x4[1, 2, 3,0]</span>
</code></pre><h3 id="simdtypestore">SIMD.%type%.store() <a class="markdownIt-Anchor" href="#simdtypestore">#</a></h3><p><code>store</code>方法用于将一个 SIMD 值，写入一个二进制数组。它接受三个参数，分别是二进制数组、开始写入的数组位置、SIMD 值。它返回写入值以后的二进制数组。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> t1 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>(<span class="hljs-number">8</span>);
<span class="hljs-keyword">var</span> v1 = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">store</span>(t1, <span class="hljs-number">0</span>, v1)
<span class="hljs-comment">// Int32Array[1, 2, 3, 4, 0, 0, 0, 0]</span>

<span class="hljs-keyword">var</span> t2 = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>(<span class="hljs-number">8</span>);
<span class="hljs-keyword">var</span> v2 = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">store</span>(t2, <span class="hljs-number">2</span>, v2)
<span class="hljs-comment">// Int32Array[0, 0, 1, 2, 3, 4, 0, 0]</span>
</code></pre><p>上面代码中，<code>t1</code>是一个二进制数组，<code>v1</code>是一个 SIMD 值，只有四个通道。所以写入<code>t1</code>以后，只有前四个位置有值，后四个位置都是 0。而<code>t2</code>是从 2 号位置开始写入，所以前两个位置和后两个位置都是 0。</p><p>这个方法还有三个变种<code>store1()</code>、<code>store2()</code>和<code>store3()</code>，表示只写入一个通道、二个通道和三个通道的值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> tarray = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Int32Array</span>(<span class="hljs-number">8</span>);
<span class="hljs-keyword">var</span> value = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">store1</span>(tarray, <span class="hljs-number">0</span>, value);
<span class="hljs-comment">// Int32Array[1, 0, 0, 0, 0, 0, 0, 0]</span>
</code></pre><h3 id="simdtypesplat">SIMD.%type%.splat() <a class="markdownIt-Anchor" href="#simdtypesplat">#</a></h3><p><code>splat</code>方法返回一个新的 SIMD 值，该值的所有通道都会设成同一个预先给定的值。</p><pre class="hljs"><code><span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">splat</span>(<span class="hljs-number">3</span>);
<span class="hljs-comment">// Float32x4[3, 3, 3, 3]</span>
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float64x2</span>.<span class="hljs-title function_">splat</span>(<span class="hljs-number">3</span>);
<span class="hljs-comment">// Float64x2[3, 3]</span>
</code></pre><p>如果省略参数，所有整数型的 SIMD 值都会设定<code>0</code>，浮点型的 SIMD 值都会设成<code>NaN</code>。</p><h3 id="simdtypeswizzle">SIMD.%type%.swizzle() <a class="markdownIt-Anchor" href="#simdtypeswizzle">#</a></h3><p><code>swizzle</code>方法返回一个新的 SIMD 值，重新排列原有的 SIMD 值的通道顺序。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> t = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">swizzle</span>(t, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// Float32x4[2,3,1,4]</span>
</code></pre><p>上面代码中，<code>swizzle</code>方法的第一个参数是原有的 SIMD 值，后面的参数对应将要返回的 SIMD 值的四个通道。它的意思是新的 SIMD 的四个通道，依次是原来 SIMD 值的 1 号通道、2 号通道、0 号通道、3 号通道。由于 SIMD 值最多可以有 16 个通道，所以<code>swizzle</code>方法除了第一个参数以外，最多还可以接受 16 个参数。</p><p>下面是另一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);
<span class="hljs-comment">// Float32x4[1.0, 2.0, 3.0, 4.0]</span>

<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">swizzle</span>(a, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>);
<span class="hljs-comment">// Float32x4[1.0, 1.0, 2.0, 2.0]</span>

<span class="hljs-keyword">var</span> c = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">swizzle</span>(a, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>);
<span class="hljs-comment">// Float32x4[4.0, 4.0, 4.0, 4.0]</span>

<span class="hljs-keyword">var</span> d = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">swizzle</span>(a, <span class="hljs-number">3</span>, <span class="hljs-number">2</span>, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>);
<span class="hljs-comment">// Float32x4[4.0, 3.0, 2.0, 1.0]</span>
</code></pre><h3 id="simdtypeshuffle">SIMD.%type%.shuffle() <a class="markdownIt-Anchor" href="#simdtypeshuffle">#</a></h3><p><code>shuffle</code>方法从两个 SIMD 值之中取出指定通道，返回一个新的 SIMD 值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">shuffle</span>(a, b, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">7</span>, <span class="hljs-number">2</span>);
<span class="hljs-comment">// Float32x4[2, 6, 8, 3]</span>
</code></pre><p>上面代码中，<code>a</code>和<code>b</code>一共有 8 个通道，依次编号为 0 到 7。<code>shuffle</code>根据编号，取出相应的通道，返回一个新的 SIMD 值。</p><h2 id="静态方法比较运算">静态方法：比较运算 <a class="markdownIt-Anchor" href="#静态方法比较运算">#</a></h2><h3 id="simdtypeequalsimdtypenotequal">SIMD.%type%.equal()，SIMD.%type%.notEqual() <a class="markdownIt-Anchor" href="#simdtypeequalsimdtypenotequal">#</a></h3><p><code>equal</code>方法用来比较两个 SIMD 值<code>a</code>和<code>b</code>的每一个通道，根据两者是否精确相等（<code>a === b</code>），得到一个布尔值。最后，所有通道的比较结果，组成一个新的 SIMD 值，作为掩码返回。<code>notEqual</code>方法则是比较两个通道是否不相等（<code>a !== b</code>）。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">9</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>);

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">equal</span>(a,b)
<span class="hljs-comment">// Bool32x4[true, false, false, true]</span>

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">notEqual</span>(a,b);
<span class="hljs-comment">// Bool32x4[false, true, true, false]</span>
</code></pre><h3 id="simdtypegreaterthansimdtypegreaterthanorequal">SIMD.%type%.greaterThan()，SIMD.%type%.greaterThanOrEqual() <a class="markdownIt-Anchor" href="#simdtypegreaterthansimdtypegreaterthanorequal">#</a></h3><p><code>greatThan</code>方法用来比较两个 SIMD 值<code>a</code>和<code>b</code>的每一个通道，如果在该通道中，<code>a</code>较大就得到<code>true</code>，否则得到<code>false</code>。最后，所有通道的比较结果，组成一个新的 SIMD 值，作为掩码返回。<code>greaterThanOrEqual</code>则是比较<code>a</code>是否大于等于<code>b</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">3</span>, <span class="hljs-number">11</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>);

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">greaterThan</span>(a, b)
<span class="hljs-comment">// Bool32x4[false, true, false, true]</span>

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">greaterThanOrEqual</span>(a, b)
<span class="hljs-comment">// Bool32x4[true, true, false, true]</span>
</code></pre><h3 id="simdtypelessthansimdtypelessthanorequal">SIMD.%type%.lessThan()，SIMD.%type%.lessThanOrEqual() <a class="markdownIt-Anchor" href="#simdtypelessthansimdtypelessthanorequal">#</a></h3><p><code>lessThan</code>方法用来比较两个 SIMD 值<code>a</code>和<code>b</code>的每一个通道，如果在该通道中，<code>a</code>较小就得到<code>true</code>，否则得到<code>false</code>。最后，所有通道的比较结果，会组成一个新的 SIMD 值，作为掩码返回。<code>lessThanOrEqual</code>方法则是比较<code>a</code>是否等于<code>b</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">11</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>);

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">lessThan</span>(a, b)
<span class="hljs-comment">// Bool32x4[false, true, true, false]</span>

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">lessThanOrEqual</span>(a, b)
<span class="hljs-comment">// Bool32x4[true, true, true, false]</span>
</code></pre><h3 id="simdtypeselect">SIMD.%type%.select() <a class="markdownIt-Anchor" href="#simdtypeselect">#</a></h3><p><code>select</code>方法通过掩码生成一个新的 SIMD 值。它接受三个参数，分别是掩码和两个 SIMD 值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>);

<span class="hljs-keyword">var</span> mask = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Bool32</span>x4(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>);

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">select</span>(mask, a, b);
<span class="hljs-comment">// Float32x4[1, 6, 7, 4]</span>
</code></pre><p>上面代码中，<code>select</code>方法接受掩码和两个 SIMD 值作为参数。当某个通道对应的掩码为<code>true</code>时，会选择第一个 SIMD 值的对应通道，否则选择第二个 SIMD 值的对应通道。</p><p>这个方法通常与比较运算符结合使用。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">0</span>, <span class="hljs-number">12</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">0</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">50</span>);

<span class="hljs-keyword">var</span> mask = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">lessThan</span>(a,b);
<span class="hljs-comment">// Bool32x4[false, false, true, true]</span>

<span class="hljs-keyword">var</span> result = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">select</span>(mask, a, b);
<span class="hljs-comment">// Float32x4[0, 6, 3, 4]</span>
</code></pre><p>上面代码中，先通过<code>lessThan</code>方法生成一个掩码，然后通过<code>select</code>方法生成一个由每个通道的较小值组成的新的 SIMD 值。</p><h3 id="simdbooleantypealltruesimdbooleantypeanytrue">SIMD.%BooleanType%.allTrue()，SIMD.%BooleanType%.anyTrue() <a class="markdownIt-Anchor" href="#simdbooleantypealltruesimdbooleantypeanytrue">#</a></h3><p><code>allTrue</code>方法接受一个 SIMD 值作为参数，然后返回一个布尔值，表示该 SIMD 值的所有通道是否都为<code>true</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Bool32</span>x4(<span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Bool32</span>x4(<span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">true</span>);

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Bool32x4</span>.<span class="hljs-title function_">allTrue</span>(a); <span class="hljs-comment">// true</span>
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Bool32x4</span>.<span class="hljs-title function_">allTrue</span>(b); <span class="hljs-comment">// false</span>
</code></pre><p><code>anyTrue</code>方法则是只要有一个通道为<code>true</code>，就返回<code>true</code>，否则返回<code>false</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Bool32</span>x4(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Bool32</span>x4(<span class="hljs-literal">false</span>, <span class="hljs-literal">false</span>, <span class="hljs-literal">true</span>, <span class="hljs-literal">false</span>);

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Bool32x4</span>.<span class="hljs-title function_">anyTrue</span>(a); <span class="hljs-comment">// false</span>
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Bool32x4</span>.<span class="hljs-title function_">anyTrue</span>(b); <span class="hljs-comment">// true</span>
</code></pre><p>注意，只有四种布尔值数据类型（<code>Bool32x4</code>、<code>Bool16x8</code>、<code>Bool8x16</code>、<code>Bool64x2</code>）才有这两个方法。</p><p>这两个方法通常与比较运算符结合使用。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> ax4    = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);
<span class="hljs-keyword">var</span> bx4    = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">0.0</span>, <span class="hljs-number">6.0</span>, <span class="hljs-number">7.0</span>, <span class="hljs-number">8.0</span>);
<span class="hljs-keyword">var</span> ix4    = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">lessThan</span>(ax4, bx4);
<span class="hljs-keyword">var</span> b1     = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">allTrue</span>(ix4); <span class="hljs-comment">// false</span>
<span class="hljs-keyword">var</span> b2     = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">anyTrue</span>(ix4); <span class="hljs-comment">// true</span>
</code></pre><h3 id="simdtypeminsimdtypeminnum">SIMD.%type%.min()，SIMD.%type%.minNum() <a class="markdownIt-Anchor" href="#simdtypeminsimdtypeminnum">#</a></h3><p><code>min</code>方法接受两个 SIMD 值作为参数，将两者的对应通道的较小值，组成一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5.2</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">0</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5.5</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">min</span>(a, b);
<span class="hljs-comment">// Float32x4[-1, -4, 3, 5.2]</span>
</code></pre><p>如果有一个通道的值是<code>NaN</code>，则会优先返回<code>NaN</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> c = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float64</span>x2(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">Infinity</span>)
<span class="hljs-keyword">var</span> d = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float64</span>x2(<span class="hljs-number">1337</span>, <span class="hljs-number">42</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float64x2</span>.<span class="hljs-title function_">min</span>(c, d);
<span class="hljs-comment">// Float64x2[NaN, 42]</span>
</code></pre><p><code>minNum</code>方法与<code>min</code>的作用一模一样，唯一的区别是如果有一个通道的值是<code>NaN</code>，则会优先返回另一个通道的值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> ax4 = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">NaN</span>);
<span class="hljs-keyword">var</span> bx4 = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">2.0</span>, <span class="hljs-number">1.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-title class_">NaN</span>);
<span class="hljs-keyword">var</span> cx4 = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">min</span>(ax4, bx4);
<span class="hljs-comment">// Float32x4[1.0, 1.0, NaN, NaN]</span>
<span class="hljs-keyword">var</span> dx4 = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">minNum</span>(ax4, bx4);
<span class="hljs-comment">// Float32x4[1.0, 1.0, 3.0, NaN]</span>
</code></pre><h3 id="simdtypemaxsimdtypemaxnum">SIMD.%type%.max()，SIMD.%type%.maxNum() <a class="markdownIt-Anchor" href="#simdtypemaxsimdtypemaxnum">#</a></h3><p><code>max</code>方法接受两个 SIMD 值作为参数，将两者的对应通道的较大值，组成一个新的 SIMD 值返回。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(-<span class="hljs-number">1</span>, -<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5.2</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">0</span>, -<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">5.5</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">max</span>(a, b);
<span class="hljs-comment">// Float32x4[0, -2, 6, 5.5]</span>
</code></pre><p>如果有一个通道的值是<code>NaN</code>，则会优先返回<code>NaN</code>。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> c = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float64</span>x2(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">Infinity</span>)
<span class="hljs-keyword">var</span> d = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float64</span>x2(<span class="hljs-number">1337</span>, <span class="hljs-number">42</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float64x2</span>.<span class="hljs-title function_">max</span>(c, d)
<span class="hljs-comment">// Float64x2[NaN, Infinity]</span>
</code></pre><p><code>maxNum</code>方法与<code>max</code>的作用一模一样，唯一的区别是如果有一个通道的值是<code>NaN</code>，则会优先返回另一个通道的值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> c = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float64</span>x2(<span class="hljs-title class_">NaN</span>, <span class="hljs-title class_">Infinity</span>)
<span class="hljs-keyword">var</span> d = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float64</span>x2(<span class="hljs-number">1337</span>, <span class="hljs-number">42</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float64x2</span>.<span class="hljs-title function_">maxNum</span>(c, d)
<span class="hljs-comment">// Float64x2[1337, Infinity]</span>
</code></pre><h2 id="静态方法位运算">静态方法：位运算 <a class="markdownIt-Anchor" href="#静态方法位运算">#</a></h2><h3 id="simdtypeandsimdtypeorsimdtypexorsimdtypenot">SIMD.%type%.and()，SIMD.%type%.or()，SIMD.%type%.xor()，SIMD.%type%.not() <a class="markdownIt-Anchor" href="#simdtypeandsimdtypeorsimdtypexorsimdtypenot">#</a></h3><p><code>and</code>方法接受两个 SIMD 值作为参数，返回两者对应的通道进行二进制<code>AND</code>运算（<code>&amp;</code>）后得到的新的 SIMD 值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">and</span>(a, b)
<span class="hljs-comment">// Int32x4[1, 0, 4, 0]</span>
</code></pre><p>上面代码中，以通道<code>0</code>为例，<code>1</code>的二进制形式是<code>0001</code>，<code>5</code>的二进制形式是<code>01001</code>，所以进行<code>AND</code>运算以后，得到<code>0001</code>。</p><p><code>or</code>方法接受两个 SIMD 值作为参数，返回两者对应的通道进行二进制<code>OR</code>运算（<code>|</code>）后得到的新的 SIMD 值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">or</span>(a, b)
<span class="hljs-comment">// Int32x4[5, 7, 5, 13]</span>
</code></pre><p><code>xor</code>方法接受两个 SIMD 值作为参数，返回两者对应的通道进行二进制“异或”运算（<code>^</code>）后得到的新的 SIMD 值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>);
<span class="hljs-keyword">var</span> b = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>, <span class="hljs-number">5</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">xor</span>(a, b)
<span class="hljs-comment">// Int32x4[4, 7, 1, 13]</span>
</code></pre><p><code>not</code>方法接受一个 SIMD 值作为参数，返回每个通道进行二进制“否”运算（<code>~</code>）后得到的新的 SIMD 值。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Int32</span>x4(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">8</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">not</span>(a)
<span class="hljs-comment">// Int32x4[-2, -3, -5, -9]</span>
</code></pre><p>上面代码中，<code>1</code>的否运算之所以得到<code>-2</code>，是因为在计算机内部，负数采用”2 的补码“这种形式进行表示。也就是说，整数<code>n</code>的负数形式<code>-n</code>，是对每一个二进制位取反以后，再加上 1。因此，直接取反就相当于负数形式再减去 1，比如<code>1</code>的负数形式是<code>-1</code>，再减去 1，就得到了<code>-2</code>。</p><h2 id="静态方法数据类型转换">静态方法：数据类型转换 <a class="markdownIt-Anchor" href="#静态方法数据类型转换">#</a></h2><p>SIMD 提供以下方法，用来将一种数据类型转为另一种数据类型。</p><ul><li><code>SIMD.%type%.fromFloat32x4()</code></li><li><code>SIMD.%type%.fromFloat32x4Bits()</code></li><li><code>SIMD.%type%.fromFloat64x2Bits()</code></li><li><code>SIMD.%type%.fromInt32x4()</code></li><li><code>SIMD.%type%.fromInt32x4Bits()</code></li><li><code>SIMD.%type%.fromInt16x8Bits()</code></li><li><code>SIMD.%type%.fromInt8x16Bits()</code></li><li><code>SIMD.%type%.fromUint32x4()</code></li><li><code>SIMD.%type%.fromUint32x4Bits()</code></li><li><code>SIMD.%type%.fromUint16x8Bits()</code></li><li><code>SIMD.%type%.fromUint8x16Bits()</code></li></ul><p>带有<code>Bits</code>后缀的方法，会原封不动地将二进制位拷贝到新的数据类型；不带后缀的方法，则会进行数据类型转换。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> t = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">fromFloat32x4</span>(t);
<span class="hljs-comment">// Int32x4[1, 2, 3, 4]</span>

<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int32x4</span>.<span class="hljs-title function_">fromFloat32x4Bits</span>(t);
<span class="hljs-comment">// Int32x4[1065353216, 1073741824, 1077936128, 1082130432]</span>
</code></pre><p>上面代码中，<code>fromFloat32x4</code>是将浮点数转为整数，然后存入新的数据类型；<code>fromFloat32x4Bits</code>则是将二进制位原封不动地拷贝进入新的数据类型，然后进行解读。</p><p><code>Bits</code>后缀的方法，还可以用于通道数目不对等的拷贝。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> t = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">1.0</span>, <span class="hljs-number">2.0</span>, <span class="hljs-number">3.0</span>, <span class="hljs-number">4.0</span>);
<span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Int16x8</span>.<span class="hljs-title function_">fromFloat32x4Bits</span>(t);
<span class="hljs-comment">// Int16x8[0, 16256, 0, 16384, 0, 16448, 0, 16512]</span>
</code></pre><p>上面代码中，原始 SIMD 值<code>t</code>是 4 通道的，而目标值是 8 通道的。</p><p>如果数据转换时，原通道的数据大小，超过了目标通道的最大宽度，就会报错。</p><h2 id="实例方法">实例方法 <a class="markdownIt-Anchor" href="#实例方法">#</a></h2><h3 id="simdtypeprototypetostring">SIMD.%type%.prototype.toString() <a class="markdownIt-Anchor" href="#simdtypeprototypetostring">#</a></h3><p><code>toString</code>方法返回一个 SIMD 值的字符串形式。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> a = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-title class_">Float32</span>x4(<span class="hljs-number">11</span>, <span class="hljs-number">22</span>, <span class="hljs-number">33</span>, <span class="hljs-number">44</span>);
a.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// &quot;SIMD.Float32x4(11, 22, 33, 44)&quot;</span>
</code></pre><h2 id="实例求平均值">实例：求平均值 <a class="markdownIt-Anchor" href="#实例求平均值">#</a></h2><p>正常模式下，计算<code>n</code>个值的平均值，需要运算<code>n</code>次。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">list</span>) {
  <span class="hljs-keyword">var</span> n = list.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0.0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) {
    sum += list[i];
  }
  <span class="hljs-keyword">return</span> sum / n;
}
</code></pre><p>使用 SIMD，可以将计算次数减少到<code>n</code>次的四分之一。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">average</span>(<span class="hljs-params">list</span>) {
  <span class="hljs-keyword">var</span> n = list.<span class="hljs-property">length</span>;
  <span class="hljs-keyword">var</span> sum = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">splat</span>(<span class="hljs-number">0.0</span>);
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; n; i += <span class="hljs-number">4</span>) {
    sum = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">add</span>(
      sum,
      <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">load</span>(list, i)
    );
  }
  <span class="hljs-keyword">var</span> total = <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">extractLane</span>(sum, <span class="hljs-number">0</span>) +
              <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">extractLane</span>(sum, <span class="hljs-number">1</span>) +
              <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">extractLane</span>(sum, <span class="hljs-number">2</span>) +
              <span class="hljs-variable constant_">SIMD</span>.<span class="hljs-property">Float32x4</span>.<span class="hljs-title function_">extractLane</span>(sum, <span class="hljs-number">3</span>);
  <span class="hljs-keyword">return</span> total / n;
}
</code></pre><p>上面代码先是每隔四位，将所有的值读入一个 SIMD，然后立刻累加。然后，得到累加值四个通道的总和，再除以<code>n</code>就可以了。</p></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../es6/fp.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> 函数式编程</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../es6/reference.html">参考链接 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>分享本文 <span class="social-share"></span></p></div></div><div class="column" style="flex:none;width:14%"><nav class="panel-info" style="border: 1px solid #ededed;"><p class="panel-heading" style="font-size: 1.0em;border-radius:0px;padding: 0.5em 0em;text-align: center;"><i class="fa fa-list-ul" aria-hidden="true"></i> Web前端教程</p><div class="panel-block" style="padding: 5px 0px;"><aside class="menu"><ul class="menu-list"><li><a href="/html/intro.html" target="_blank">&nbsp;HTML 教程</a></li><li><a href="/es6/intro.html" target="_blank">&nbsp;ES6 教程</a></li><li><a href="/typescript/intro.html" target="_blank">&nbsp;TypeScript 教程</a></li><!-- 
      <li><a href="/css/intro.html" target="_blank">&nbsp;CSS 教程</a></li>
    <li><a href="/javascript/intro.html" target="_blank">&nbsp;JavaScript 教程</a></li>
      <li><a href="/webapi/intro.html" target="_blank">&nbsp;Web API 教程</a></li>
    --></ul></aside></div></nav></div></div></div></section><footer class="footer"><div class="container" style="max-width:1260px;"><div class="content has-text-centered"><p>V站（ViJian.com），今天学全栈，明天自己干</p></div></div></footer><script>var LOPPO={current_path:"es6/simd.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E6%A6%82%E8%BF%B0">概述</a></li>\n<li><a href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B">数据类型</a></li>\n<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%95%B0%E5%AD%A6%E8%BF%90%E7%AE%97">静态方法：数学运算</a>\n<ul>\n<li><a href="#simdtypeabssimdtypeneg">SIMD.%type%.abs()，SIMD.%type%.neg()</a></li>\n<li><a href="#simdtypeaddsimdtypeaddsaturate">SIMD.%type%.add()，SIMD.%type%.addSaturate()</a></li>\n<li><a href="#simdtypesubsimdtypesubsaturate">SIMD.%type%.sub()，SIMD.%type%.subSaturate()</a></li>\n<li><a href="#simdtypemulsimdtypedivsimdtypesqrt">SIMD.%type%.mul()，SIMD.%type%.div()，SIMD.%type%.sqrt()</a></li>\n<li><a href="#simdfloattypereciprocalapproximationsimdtypereciprocalsqrtapproximation">SIMD.%FloatType%.reciprocalApproximation()，SIMD.%type%.reciprocalSqrtApproximation()</a></li>\n<li><a href="#simdintegertypeshiftleftbyscalar">SIMD.%IntegerType%.shiftLeftByScalar()</a></li>\n<li><a href="#simdintegertypeshiftrightbyscalar">SIMD.%IntegerType%.shiftRightByScalar()</a></li>\n</ul>\n</li>\n<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E9%80%9A%E9%81%93%E5%A4%84%E7%90%86">静态方法：通道处理</a>\n<ul>\n<li><a href="#simdtypecheck">SIMD.%type%.check()</a></li>\n<li><a href="#simdtypeextractlanesimdtypereplacelane">SIMD.%type%.extractLane()，SIMD.%type%.replaceLane()</a></li>\n<li><a href="#simdtypeload">SIMD.%type%.load()</a></li>\n<li><a href="#simdtypestore">SIMD.%type%.store()</a></li>\n<li><a href="#simdtypesplat">SIMD.%type%.splat()</a></li>\n<li><a href="#simdtypeswizzle">SIMD.%type%.swizzle()</a></li>\n<li><a href="#simdtypeshuffle">SIMD.%type%.shuffle()</a></li>\n</ul>\n</li>\n<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%AF%94%E8%BE%83%E8%BF%90%E7%AE%97">静态方法：比较运算</a>\n<ul>\n<li><a href="#simdtypeequalsimdtypenotequal">SIMD.%type%.equal()，SIMD.%type%.notEqual()</a></li>\n<li><a href="#simdtypegreaterthansimdtypegreaterthanorequal">SIMD.%type%.greaterThan()，SIMD.%type%.greaterThanOrEqual()</a></li>\n<li><a href="#simdtypelessthansimdtypelessthanorequal">SIMD.%type%.lessThan()，SIMD.%type%.lessThanOrEqual()</a></li>\n<li><a href="#simdtypeselect">SIMD.%type%.select()</a></li>\n<li><a href="#simdbooleantypealltruesimdbooleantypeanytrue">SIMD.%BooleanType%.allTrue()，SIMD.%BooleanType%.anyTrue()</a></li>\n<li><a href="#simdtypeminsimdtypeminnum">SIMD.%type%.min()，SIMD.%type%.minNum()</a></li>\n<li><a href="#simdtypemaxsimdtypemaxnum">SIMD.%type%.max()，SIMD.%type%.maxNum()</a></li>\n</ul>\n</li>\n<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E4%BD%8D%E8%BF%90%E7%AE%97">静态方法：位运算</a>\n<ul>\n<li><a href="#simdtypeandsimdtypeorsimdtypexorsimdtypenot">SIMD.%type%.and()，SIMD.%type%.or()，SIMD.%type%.xor()，SIMD.%type%.not()</a></li>\n</ul>\n</li>\n<li><a href="#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2">静态方法：数据类型转换</a></li>\n<li><a href="#%E5%AE%9E%E4%BE%8B%E6%96%B9%E6%B3%95">实例方法</a>\n<ul>\n<li><a href="#simdtypeprototypetostring">SIMD.%type%.prototype.toString()</a></li>\n</ul>\n</li>\n<li><a href="#%E5%AE%9E%E4%BE%8B%E6%B1%82%E5%B9%B3%E5%9D%87%E5%80%BC">实例：求平均值</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script><!--script src="../assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《ES6 SIMD》，出自V站（ViJian.com）。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"ViJian_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>