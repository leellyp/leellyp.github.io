<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>ES6函数式编程 - ES6教程 - V站前端教程</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="../assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="../assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="ES6函数式编程"><link rel="apple-touch-icon" href="../assets/icons/logo.png"><link rel="icon" type="image/png" href="../assets/icons/logo.png"><style>.nav-item-active{background-color: #fff;color:#9cba39}
      a{color:#399ab2}
      a:hover{color:#9cba39}
      .breadcrumb a{color:#399ab2}
      .breadcrumb a:hover{color:#9cba39}
      .navbar.is-light .navbar-end .navbar-link, .navbar.is-light .navbar-end>.navbar-item, 
      .navbar.is-light .navbar-start>.navbar-item:hover{color:#9cba39}
      .navbar-link, a.navbar-item:hover{color:#9cba39}

      .panel-info .panel-block .menu-list a.is-active, .panel-menu .panel-block .menu-list a.is-active {
        color: #fff;
        background-color: #399ab2;
      }
      .menu-list>li{background:#F9F9F9;border-bottom: 1px solid #ededed;} 
      .panel-info .panel-block .menu, .panel-menu .panel-block .menu{padding:0 5px}</style></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container" style="max-width:1230px;"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">V站 / ViJian.com</a></div><div class="navbar-menu" id="navMenu"><div class="navbar-start"><div class="navbar-item"><a class="navbar-item" href="/">首页</a></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link nav-item-active is-hidden-touch">教程</a><div class="navbar-dropdown"><a class="navbar-item" href="/html/intro.html">HTML 教程</a> <a class="navbar-item" href="/es6/intro.html">ES6 教程</a> <a class="navbar-item" href="/typescript/intro.html">TypeScript 教程</a><!--   <a class="navbar-item" href="/webapi/intro.html">Web API 教程</a>
             <a class="navbar-item" href="/css/intro.html">CSS 教程</a>
        <a class="navbar-item" href="/javascript/intro.html">JavaScript 教程</a> --></div></div></div><div class="navbar-end"></div></div></div></nav><section class="section main article" style="padding-top: 20px;"><div class="container" style="max-width:1260px;"><div class="columns"><div class="column" style="flex:none;width:16%"><nav class="panel-menu" style="border: 1px solid #ededed;"><p class="panel-heading" style="font-size: 1.0em;border-radius:0px;padding: 0.5em 0em;text-align: center;"><i class="fa fa-book" aria-hidden="true"></i> ES6教程</p><div class="panel-block" style="padding: 5px 0px;"><aside class="menu"><ul class="menu-list"><li><a href="../es6/intro.html">&nbsp; <span class="menu-list-title" style="width:100%">简介</span></a></li><li><a href="../es6/let.html">&nbsp; <span class="menu-list-title" style="width:100%">let 和 const 命令</span></a></li><li><a href="../es6/destructuring.html">&nbsp; <span class="menu-list-title" style="width:100%">变量的解构赋值</span></a></li><li><a href="../es6/string.html">&nbsp; <span class="menu-list-title" style="width:100%">字符串的扩展</span></a></li><li><a href="../es6/string-methods.html">&nbsp; <span class="menu-list-title" style="width:100%">字符串的新增方法</span></a></li><li><a href="../es6/regex.html">&nbsp; <span class="menu-list-title" style="width:100%">正则的扩展</span></a></li><li><a href="../es6/number.html">&nbsp; <span class="menu-list-title" style="width:100%">数值的扩展</span></a></li><li><a href="../es6/function.html">&nbsp; <span class="menu-list-title" style="width:100%">函数的扩展</span></a></li><li><a href="../es6/array.html">&nbsp; <span class="menu-list-title" style="width:100%">数组的扩展</span></a></li><li><a href="../es6/object.html">&nbsp; <span class="menu-list-title" style="width:100%">对象的扩展</span></a></li><li><a href="../es6/object-methods.html">&nbsp; <span class="menu-list-title" style="width:100%">对象的新增方法</span></a></li><li><a href="../es6/operator.html">&nbsp; <span class="menu-list-title" style="width:100%">运算符的扩展</span></a></li><li><a href="../es6/symbol.html">&nbsp; <span class="menu-list-title" style="width:100%">Symbol</span></a></li><li><a href="../es6/set-map.html">&nbsp; <span class="menu-list-title" style="width:100%">Set 和 Map 数据结构</span></a></li><li><a href="../es6/proxy.html">&nbsp; <span class="menu-list-title" style="width:100%">Proxy</span></a></li><li><a href="../es6/reflect.html">&nbsp; <span class="menu-list-title" style="width:100%">Reflect</span></a></li><li><a href="../es6/promise.html">&nbsp; <span class="menu-list-title" style="width:100%">Promise 对象</span></a></li><li><a href="../es6/iterator.html">&nbsp; <span class="menu-list-title" style="width:100%">Iterator 和 for...of 循环</span></a></li><li><a href="../es6/generator.html">&nbsp; <span class="menu-list-title" style="width:100%">Generator 函数的语法</span></a></li><li><a href="../es6/generator-async.html">&nbsp; <span class="menu-list-title" style="width:100%">Generator 函数的异步应用</span></a></li><li><a href="../es6/async.html">&nbsp; <span class="menu-list-title" style="width:100%">async 函数</span></a></li><li><a href="../es6/class.html">&nbsp; <span class="menu-list-title" style="width:100%">Class 的基本语法</span></a></li><li><a href="../es6/class-extends.html">&nbsp; <span class="menu-list-title" style="width:100%">Class 的继承</span></a></li><li><a href="../es6/module.html">&nbsp; <span class="menu-list-title" style="width:100%">Module 的语法</span></a></li><li><a href="../es6/module-loader.html">&nbsp; <span class="menu-list-title" style="width:100%">Module 的加载实现</span></a></li><li><a href="../es6/style.html">&nbsp; <span class="menu-list-title" style="width:100%">编程风格</span></a></li><li><a href="../es6/spec.html">&nbsp; <span class="menu-list-title" style="width:100%">读懂 ECMAScript 规格</span></a></li><li><a href="../es6/async-iterator.html">&nbsp; <span class="menu-list-title" style="width:100%">异步遍历器</span></a></li><li><a href="../es6/arraybuffer.html">&nbsp; <span class="menu-list-title" style="width:100%">ArrayBuffer</span></a></li><li><a href="../es6/proposals.html">&nbsp; <span class="menu-list-title" style="width:100%">最新提案</span></a></li><li><a href="../es6/decorator.html">&nbsp; <span class="menu-list-title" style="width:100%">装饰器</span></a></li><li><a href="../es6/mixin.html">&nbsp; <span class="menu-list-title" style="width:100%">Mixin</span></a></li><li><a href="../es6/fp.html" class="is-active">&nbsp; <span class="menu-list-title" style="width:100%">函数式编程</span></a></li><li><a href="../es6/simd.html">&nbsp; <span class="menu-list-title" style="width:100%">SIMD</span></a></li><li><a href="../es6/reference.html">&nbsp; <span class="menu-list-title" style="width:100%">参考链接</span></a></li></ul></aside></div></nav></div><div class="column" style="flex:none;width:68%"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="../"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;V站</a></li><li><a href="../es6/fp.html/intro.html">ES6教程</a></li><li><a href="../es6/fp.html">ES6 函数式编程</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../es6/mixin.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> Mixin</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../es6/simd.html">SIMD <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">ES6 函数式编程</h1><div class="page-meta"><p>V站（ViJian.com）</p></div><p>JavaScript 语言从一诞生，就具有函数式编程的烙印。它将函数作为一种独立的数据类型，与其他数据类型处于完全平等的地位。在 JavaScript 语言中，你可以采用面向对象编程，也可以采用函数式编程。有人甚至说，JavaScript 是有史以来第一种被大规模采用的函数式编程语言。</p><p>ES6 的种种新增功能，使得函数式编程变得更方便、更强大。本章介绍 ES6 如何进行函数式编程。</p><h2 id="柯里化">柯里化 <a class="markdownIt-Anchor" href="#柯里化">#</a></h2><p>柯里化（currying）指的是将一个多参数的函数拆分成一系列函数，每个拆分后的函数都只接受一个参数（unary）。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (a, b) {
  <span class="hljs-keyword">return</span> a + b;
}

<span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span>
</code></pre><p>上面代码中，函数<code>add</code>接受两个参数<code>a</code>和<code>b</code>。</p><p>柯里化就是将上面的函数拆分成两个函数，每个函数都只接受一个参数。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (a) {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) {
    <span class="hljs-keyword">return</span> a + b;
  }
}
<span class="hljs-comment">// 或者采用箭头函数写法</span>
<span class="hljs-keyword">const</span> <span class="hljs-title function_">add</span> = x =&gt; <span class="hljs-function"><span class="hljs-params">y</span> =&gt;</span> x + y;

<span class="hljs-keyword">const</span> f = <span class="hljs-title function_">add</span>(<span class="hljs-number">1</span>);
<span class="hljs-title function_">f</span>(<span class="hljs-number">1</span>) <span class="hljs-comment">// 2</span>
</code></pre><p>上面代码中，函数<code>add</code>只接受一个参数<code>a</code>，返回一个函数<code>f</code>。函数<code>f</code>也只接受一个参数<code>b</code>。</p><h2 id="函数合成">函数合成 <a class="markdownIt-Anchor" href="#函数合成">#</a></h2><p>函数合成（function composition）指的是，将多个函数合成一个函数。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-title function_">compose</span> = f =&gt; <span class="hljs-function"><span class="hljs-params">g</span> =&gt;</span> <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-title function_">f</span>(<span class="hljs-title function_">g</span>(x));

<span class="hljs-keyword">const</span> f = compose (<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x * <span class="hljs-number">4</span>) (<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x + <span class="hljs-number">3</span>);
<span class="hljs-title function_">f</span>(<span class="hljs-number">2</span>) <span class="hljs-comment">// 20</span>
</code></pre><p>上面代码中，<code>compose</code>就是一个函数合成器，用于将两个函数合成一个函数。</p><p>可以发现，柯里化与函数合成有着密切的联系。前者用于将一个函数拆成多个函数，后者用于将多个函数合并成一个函数。</p><h2 id="参数倒置">参数倒置 <a class="markdownIt-Anchor" href="#参数倒置">#</a></h2><p>参数倒置（flip）指的是改变函数前两个参数的顺序。</p><pre class="hljs"><code><span class="hljs-keyword">var</span> <span class="hljs-title function_">divide</span> = (<span class="hljs-params">a, b</span>) =&gt; a / b;
<span class="hljs-keyword">var</span> flip = f.<span class="hljs-title function_">flip</span>(divide);

<span class="hljs-title function_">flip</span>(<span class="hljs-number">10</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// 0.5</span>
<span class="hljs-title function_">flip</span>(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>) <span class="hljs-comment">// 10</span>

<span class="hljs-keyword">var</span> <span class="hljs-title function_">three</span> = (<span class="hljs-params">a, b, c</span>) =&gt; [a, b, c];
<span class="hljs-keyword">var</span> flip = f.<span class="hljs-title function_">flip</span>(three);
<span class="hljs-title function_">flip</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>); <span class="hljs-comment">// =&gt; [2, 1, 3]</span>
</code></pre><p>上面代码中，如果按照正常的参数顺序，10 除以 5 等于 2。但是，参数倒置以后得到的新函数，结果就是 5 除以 10，结果得到 0.5。如果原函数有 3 个参数，则只颠倒前两个参数的位置。</p><p>参数倒置的代码非常简单。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> f = {};
f.<span class="hljs-property">flip</span> =
  <span class="hljs-function"><span class="hljs-params">fn</span> =&gt;</span>
    <span class="hljs-function">(<span class="hljs-params">a, b, ...args</span>) =&gt;</span> <span class="hljs-title function_">fn</span>(b, a, ...args.<span class="hljs-title function_">reverse</span>());
</code></pre><h2 id="执行边界">执行边界 <a class="markdownIt-Anchor" href="#执行边界">#</a></h2><p>执行边界（until）指的是函数执行到满足条件为止。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-title function_">condition</span> = x =&gt; x &gt; <span class="hljs-number">100</span>;
<span class="hljs-keyword">let</span> <span class="hljs-title function_">inc</span> = x =&gt; x + <span class="hljs-number">1</span>;
<span class="hljs-keyword">let</span> until = f.<span class="hljs-title function_">until</span>(condition, inc);

<span class="hljs-title function_">until</span>(<span class="hljs-number">0</span>) <span class="hljs-comment">// 101</span>

condition = <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x === <span class="hljs-number">5</span>;
until = f.<span class="hljs-title function_">until</span>(condition, inc);

<span class="hljs-title function_">until</span>(<span class="hljs-number">3</span>) <span class="hljs-comment">// 5</span>
</code></pre><p>上面代码中，第一段的条件是执行到<code>x</code>大于 100 为止，所以<code>x</code>初值为 0 时，会一直执行到 101。第二段的条件是执行到等于 5 为止，所以<code>x</code>最后的值是 5。</p><p>执行边界的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> f = {};
f.<span class="hljs-property">until</span> = <span class="hljs-function">(<span class="hljs-params">condition, f</span>) =&gt;</span>
  <span class="hljs-function">(<span class="hljs-params">...args</span>) =&gt;</span> {
    <span class="hljs-keyword">var</span> r = f.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, args);
    <span class="hljs-keyword">return</span> <span class="hljs-title function_">condition</span>(r) ? r : f.<span class="hljs-title function_">until</span>(condition, f)(r);
  };
</code></pre><p>上面代码的关键就是，如果满足条件就返回结果，否则不断递归执行。</p><h2 id="队列操作">队列操作 <a class="markdownIt-Anchor" href="#队列操作">#</a></h2><p>队列（list）操作包括以下几种。</p><ul><li><code>head</code>： 取出队列的第一个非空成员。</li><li><code>last</code>： 取出有限队列的最后一个非空成员。</li><li><code>tail</code>： 取出除了“队列头”以外的其他非空成员。</li><li><code>init</code>： 取出除了“队列尾”以外的其他非空成员。</li></ul><p>下面是例子。</p><pre class="hljs"><code>f.<span class="hljs-title function_">head</span>(<span class="hljs-number">5</span>, <span class="hljs-number">27</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 5</span>
f.<span class="hljs-title function_">last</span>(<span class="hljs-number">5</span>, <span class="hljs-number">27</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// 1</span>
f.<span class="hljs-title function_">tail</span>(<span class="hljs-number">5</span>, <span class="hljs-number">27</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [27, 3, 1]</span>
f.<span class="hljs-title function_">init</span>(<span class="hljs-number">5</span>, <span class="hljs-number">27</span>, <span class="hljs-number">3</span>, <span class="hljs-number">1</span>) <span class="hljs-comment">// [5, 27, 3]</span>
</code></pre><p>这些方法的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> f = {};
f.<span class="hljs-property">head</span> = <span class="hljs-function">(<span class="hljs-params">...xs</span>) =&gt;</span> xs[<span class="hljs-number">0</span>];
f.<span class="hljs-property">last</span> = <span class="hljs-function">(<span class="hljs-params">...xs</span>) =&gt;</span> xs.<span class="hljs-title function_">slice</span>(-<span class="hljs-number">1</span>);
f.<span class="hljs-property">tail</span> = <span class="hljs-function">(<span class="hljs-params">...xs</span>) =&gt;</span> <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">slice</span>.<span class="hljs-title function_">call</span>(xs, <span class="hljs-number">1</span>);
f.<span class="hljs-property">init</span> = <span class="hljs-function">(<span class="hljs-params">...xs</span>) =&gt;</span> xs.<span class="hljs-title function_">slice</span>(<span class="hljs-number">0</span>, -<span class="hljs-number">1</span>);
</code></pre><h2 id="合并操作">合并操作 <a class="markdownIt-Anchor" href="#合并操作">#</a></h2><p>合并操作分为<code>concat</code>和<code>concatMap</code>两种。前者就是将多个数组合成一个，后者则是先处理一下参数，然后再将处理结果合成一个数组。</p><pre class="hljs"><code>f.<span class="hljs-title function_">concat</span>([<span class="hljs-number">5</span>], [<span class="hljs-number">27</span>], [<span class="hljs-number">3</span>]) <span class="hljs-comment">// [5, 27, 3]</span>
f.<span class="hljs-title function_">concatMap</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> <span class="hljs-string">&#x27;hi &#x27;</span> + x, <span class="hljs-number">1</span>, [[<span class="hljs-number">2</span>]], <span class="hljs-number">3</span>) <span class="hljs-comment">// [&#x27;hi 1&#x27;, &#x27;hi 2&#x27;, &#x27;hi 3&#x27;]</span>
</code></pre><p>这两种方法的实现代码如下。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> f = {};
f.<span class="hljs-property">concat</span> =
  <span class="hljs-function">(<span class="hljs-params">...xs</span>) =&gt;</span> xs.<span class="hljs-title function_">reduce</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a.<span class="hljs-title function_">concat</span>(b));
f.<span class="hljs-property">concatMap</span> =
  <span class="hljs-function">(<span class="hljs-params">f, ...xs</span>) =&gt;</span> f.<span class="hljs-title function_">concat</span>(xs.<span class="hljs-title function_">map</span>(f));
</code></pre><h2 id="配对操作">配对操作 <a class="markdownIt-Anchor" href="#配对操作">#</a></h2><p>配对操作分为<code>zip</code>和<code>zipWith</code>两种方法。<code>zip</code>操作将两个队列的成员，一一配对，合成一个新的队列。如果两个队列不等长，较长的那个队列多出来的成员，会被忽略。<code>zipWith</code>操作的第一个参数是一个函数，然后会将后面的队列成员一一配对，输入该函数，返回值就组成一个新的队列。</p><p>下面是例子。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> a = [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">let</span> b = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
<span class="hljs-keyword">let</span> c = [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>];

f.<span class="hljs-title function_">zip</span>(a, b) <span class="hljs-comment">// [[0, 3], [1, 4], [2, 5]]</span>
f.<span class="hljs-title function_">zipWith</span>(<span class="hljs-function">(<span class="hljs-params">a, b</span>) =&gt;</span> a + b, a, b, c) <span class="hljs-comment">// [9, 12, 15]</span>
</code></pre><p>上面代码中，<code>zipWith</code>方法的第一个参数是一个求和函数，它将后面三个队列的成员，一一配对进行相加。</p><p>这两个方法的实现如下。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> f = {};

f.<span class="hljs-property">zip</span> = <span class="hljs-function">(<span class="hljs-params">...xs</span>) =&gt;</span> {
  <span class="hljs-keyword">let</span> r = [];
  <span class="hljs-keyword">let</span> nple = [];
  <span class="hljs-keyword">let</span> length = <span class="hljs-title class_">Math</span>.<span class="hljs-property">min</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, xs.<span class="hljs-title function_">map</span>(<span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> x.<span class="hljs-property">length</span>));

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) {
    xs.<span class="hljs-title function_">forEach</span>(
      <span class="hljs-function"><span class="hljs-params">x</span> =&gt;</span> nple.<span class="hljs-title function_">push</span>(x[i])
    );

    r.<span class="hljs-title function_">push</span>(nple);
    nple = [];
  }

  <span class="hljs-keyword">return</span> r;
};

f.<span class="hljs-property">zipWith</span> = <span class="hljs-function">(<span class="hljs-params">op, ...xs</span>) =&gt;</span>
  f.<span class="hljs-property">zip</span>.<span class="hljs-title function_">apply</span>(<span class="hljs-literal">null</span>, xs).<span class="hljs-title function_">map</span>(
    <span class="hljs-function">(<span class="hljs-params">x</span>) =&gt;</span> x.<span class="hljs-title function_">reduce</span>(op)
  );
</code></pre><h2 id="参考链接">参考链接 <a class="markdownIt-Anchor" href="#参考链接">#</a></h2><ul><li>Mateo Gianolio, <a href="http://casualjavascript.com/?1" target="_blank" rel="noopener">Haskell in ES6: Part 1</a></li></ul></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../es6/mixin.html"><span class="icon"><i class="fa fa-toggle-left"></i></span></a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../es6/simd.html"><span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>本教程采用<a href="https://creativecommons.org/licenses/by-sa/3.0/deed.zh" target="_blank">知识共享 署名-相同方式共享 3.0协议</a>。</p><p>分享本文 <span class="social-share"></span></p></div></div><div class="column" style="flex:none;width:14%"><nav class="panel-info" style="border: 1px solid #ededed;"><p class="panel-heading" style="font-size: 1.0em;border-radius:0px;padding: 0.5em 0em;text-align: center;"><i class="fa fa-list-ul" aria-hidden="true"></i> Web前端教程</p><div class="panel-block" style="padding: 5px 0px;"><aside class="menu"><ul class="menu-list"><li><a href="/html/intro.html" target="_blank">&nbsp;HTML 教程</a></li><li><a href="/es6/intro.html" target="_blank">&nbsp;ES6 教程</a></li><li><a href="/typescript/intro.html" target="_blank">&nbsp;TypeScript 教程</a></li><!-- 
      <li><a href="/css/intro.html" target="_blank">&nbsp;CSS 教程</a></li>
    <li><a href="/javascript/intro.html" target="_blank">&nbsp;JavaScript 教程</a></li>
      <li><a href="/webapi/intro.html" target="_blank">&nbsp;Web API 教程</a></li>
    --></ul></aside></div></nav></div></div></div></section><footer class="footer"><div class="container" style="max-width:1260px;"><div class="content has-text-centered"><p>V站（ViJian.com），今天学全栈，明天自己干</p></div></div></footer><script>var LOPPO={current_path:"es6/fp.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E6%9F%AF%E9%87%8C%E5%8C%96">柯里化</a></li>\n<li><a href="#%E5%87%BD%E6%95%B0%E5%90%88%E6%88%90">函数合成</a></li>\n<li><a href="#%E5%8F%82%E6%95%B0%E5%80%92%E7%BD%AE">参数倒置</a></li>\n<li><a href="#%E6%89%A7%E8%A1%8C%E8%BE%B9%E7%95%8C">执行边界</a></li>\n<li><a href="#%E9%98%9F%E5%88%97%E6%93%8D%E4%BD%9C">队列操作</a></li>\n<li><a href="#%E5%90%88%E5%B9%B6%E6%93%8D%E4%BD%9C">合并操作</a></li>\n<li><a href="#%E9%85%8D%E5%AF%B9%E6%93%8D%E4%BD%9C">配对操作</a></li>\n<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script><!--script src="../assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《ES6 函数式编程》，出自V站（ViJian.com）。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"ViJian_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script></body></html>