<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TypeScriptobject 对象 - TypeScript教程 - V站前端教程</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="../assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="../assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="TypeScriptobject 对象"><link rel="apple-touch-icon" href="../assets/icons/logo.png"><link rel="icon" type="image/png" href="../assets/icons/logo.png"><style>.nav-item-active{background-color: #fff;color:#9cba39}
      a{color:#399ab2}
      a:hover{color:#9cba39}
      .breadcrumb a{color:#399ab2}
      .breadcrumb a:hover{color:#9cba39}
      .navbar.is-light .navbar-end .navbar-link, .navbar.is-light .navbar-end>.navbar-item, 
      .navbar.is-light .navbar-start>.navbar-item:hover{color:#9cba39}
      .navbar-link, a.navbar-item:hover{color:#9cba39}
      .footer{padding:1.5rem 0;}

      .panel-info .panel-block .menu-list a.is-active, .panel-menu .panel-block .menu-list a.is-active {
        color: #fff;
        background-color: #399ab2;
      }
      .menu-list>li{background:#F9F9F9;border-bottom: 1px solid #ededed;} 
      .menu-list .menu-item-title{height: 35px;line-height: 35px;text-align: center;background-color: #EDEDED;color:#9cba39;font-weight: bold;}
      .menu-list > li > a .menu-list-title::before {
          font-weight: 700;
          content: "";
      }

      .panel-info .panel-block .menu, .panel-menu .panel-block .menu{padding:0 5px}

      
      @media screen and (max-width: 768px) {
        .column-left{
        flex: none;  display: none;
        }
        .column-main{
          flex: none; width: 100%;margin:0;padding:0 20px;
        }
        .column-right{
          flex: none; display: none;
        }

        .section{padding: 0;}
        .middle-column-home{border: 0;padding: 0 10px;}

        .codelist .codelist-ul li{float: left;width:33.33%;padding:0 8px 10px 0;height:60px;line-height: 60px;}
        .codelist .codelist-ul li .item-site{display: none;} 
        .codelist .codelist-ul li .codeicon{display: none;} 
        .codelist .codelist-ul li strong{display: none;} 
        .codelist a.item-top h4{margin: 0;padding: 0;font-size: 14px;}
      }
      @media screen and (min-width: 769px)  {
        .column-left{
          flex: none;display: block; width: 16%
        }
        .column-main{
          flex: none; width: 68%;
        }
        .column-right{
          flex: none;display: block; width: 14%
        }
     }</style></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container" style="max-width:1230px;"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">V站 / ViJian.com </a><a role="button" class="navbar-burger" data-target="navMenu" aria-label="menu" aria-expanded="false"><span aria-hidden="true"></span> <span aria-hidden="true"></span> <span aria-hidden="true"></span></a></div><div class="navbar-menu" id="navMenu"><div class="navbar-start"><div class="navbar-item"><a class="navbar-item" href="/">首页</a></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link nav-item-active is-hidden-touch">教程</a><div class="navbar-dropdown"><a class="navbar-item" href="/html/intro.html">HTML 教程</a> <a class="navbar-item" href="/javascript/intro.html">JavaScript 教程</a> <a class="navbar-item" href="/es6/intro.html">ES6 教程</a> <a class="navbar-item" href="/typescript/intro.html">TypeScript 教程</a></div></div><div class="navbar-item"><a class="navbar-item" href="/course.html">课程</a></div><div class="navbar-item"><a class="navbar-item" href="/download.html">下载</a></div><div class="navbar-item"><a class="navbar-item" href="/workroom.html">工作室</a></div></div><div class="navbar-end"></div></div></div></nav><section class="section main article" style="padding-top: 20px;"><div class="container" style="max-width:1260px;"><div class="columns"><div class="column column-left"><nav class="panel-menu" style="border: 1px solid #ededed;"><p class="panel-heading" style="font-size: 1.0em;border-radius:0px;padding: 0.5em 0em;text-align: center;"><i class="fa fa-book" aria-hidden="true"></i> TypeScript教程</p><div class="panel-block" style="padding: 5px 0px;"><aside class="menu"><ul class="menu-list"><li class="menu-item-title" data="1_item">基础类型</li><li class="1_item"><a href="../typescript/intro.html">&nbsp; <span class="menu-list-title" style="width:100%">1.语言简介</span></a></li><li class="1_item"><a href="../typescript/basic.html">&nbsp; <span class="menu-list-title" style="width:100%">2.基本用法</span></a></li><li class="1_item"><a href="../typescript/any.html">&nbsp; <span class="menu-list-title" style="width:100%">3.any 类型</span></a></li><li class="1_item"><a href="../typescript/unknown.html">&nbsp; <span class="menu-list-title" style="width:100%">4.unknown 类型</span></a></li><li class="1_item"><a href="../typescript/never.html">&nbsp; <span class="menu-list-title" style="width:100%">5.never 类型</span></a></li><li class="1_item"><a href="../typescript/types.html">&nbsp; <span class="menu-list-title" style="width:100%">6.类型系统</span></a></li><li class="1_item"><a href="../typescript/array.html">&nbsp; <span class="menu-list-title" style="width:100%">7.array 数组</span></a></li><li class="1_item"><a href="../typescript/tuple.html">&nbsp; <span class="menu-list-title" style="width:100%">8.tuple 元组</span></a></li><li class="1_item"><a href="../typescript/symbol.html">&nbsp; <span class="menu-list-title" style="width:100%">9.symbol 类型</span></a></li><li class="1_item"><a href="../typescript/function.html">&nbsp; <span class="menu-list-title" style="width:100%">10.function 函数</span></a></li><li class="1_item"><a href="../typescript/object.html" class="is-active">&nbsp; <span class="menu-list-title" style="width:100%">11.object 对象</span></a></li><li class="1_item"><a href="../typescript/module.html">&nbsp; <span class="menu-list-title" style="width:100%">12.module 模块</span></a></li><li class="menu-item-title" data="2_item">面向对象</li><li class="2_item"><a href="../typescript/interface.html">&nbsp; <span class="menu-list-title" style="width:100%">1.interface 接口</span></a></li><li class="2_item"><a href="../typescript/class.html">&nbsp; <span class="menu-list-title" style="width:100%">2.class 类型</span></a></li><li class="2_item"><a href="../typescript/generics.html">&nbsp; <span class="menu-list-title" style="width:100%">3.generics 泛型</span></a></li><li class="2_item"><a href="../typescript/enum.html">&nbsp; <span class="menu-list-title" style="width:100%">4.enum 枚举</span></a></li><li class="2_item"><a href="../typescript/namespace.html">&nbsp; <span class="menu-list-title" style="width:100%">5.namespace 命名空间</span></a></li><li class="2_item"><a href="../typescript/decorator-legacy.html">&nbsp; <span class="menu-list-title" style="width:100%">6.旧装饰器</span></a></li><li class="2_item"><a href="../typescript/decorator.html">&nbsp; <span class="menu-list-title" style="width:100%">7.decorator 装饰器</span></a></li><li class="menu-item-title" data="3_item">类型操作</li><li class="3_item"><a href="../typescript/assert.html">&nbsp; <span class="menu-list-title" style="width:100%">1.类型断言</span></a></li><li class="3_item"><a href="../typescript/d.ts.html">&nbsp; <span class="menu-list-title" style="width:100%">2.d.ts 类型声明文件</span></a></li><li class="3_item"><a href="../typescript/operator.html">&nbsp; <span class="menu-list-title" style="width:100%">3.类型运算符</span></a></li><li class="3_item"><a href="../typescript/type-operations.html">&nbsp; <span class="menu-list-title" style="width:100%">4.类型运算</span></a></li><li class="3_item"><a href="../typescript/narrowing.html">&nbsp; <span class="menu-list-title" style="width:100%">5.类型缩小</span></a></li><li class="3_item"><a href="../typescript/mapping.html">&nbsp; <span class="menu-list-title" style="width:100%">6.类型映射</span></a></li><li class="3_item"><a href="../typescript/utility.html">&nbsp; <span class="menu-list-title" style="width:100%">7.类型工具</span></a></li><li class="menu-item-title" data="4_item">其他</li><li class="4_item"><a href="../typescript/declare.html">&nbsp; <span class="menu-list-title" style="width:100%">1.declare 关键字</span></a></li><li class="4_item"><a href="../typescript/comment.html">&nbsp; <span class="menu-list-title" style="width:100%">2.注释指令</span></a></li><li class="4_item"><a href="../typescript/es6.html">&nbsp; <span class="menu-list-title" style="width:100%">3.ES6类型</span></a></li><li class="4_item"><a href="../typescript/react.html">&nbsp; <span class="menu-list-title" style="width:100%">4.React支持</span></a></li><li class="4_item"><a href="../typescript/npm.html">&nbsp; <span class="menu-list-title" style="width:100%">5.使用npm模块</span></a></li><li class="4_item"><a href="../typescript/tsc.html">&nbsp; <span class="menu-list-title" style="width:100%">6.tsc命令行编译器</span></a></li><li class="4_item"><a href="../typescript/tsconfig.json.html">&nbsp; <span class="menu-list-title" style="width:100%">7.tsconfig.json 配置文件</span></a></li></ul></aside></div></nav></div><div class="column column-main"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="../"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;V站</a></li><li><a href="../typescript/intro.html">TypeScript教程</a></li><li><a href="../typescript/object.html">TypeScript object 对象</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../typescript/function.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> function 函数</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../typescript/module.html">module 模块 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">TypeScript object 对象</h1><div class="page-meta"><p>V站（ViJian.com）</p></div><h2 id="简介">简介 <a class="markdownIt-Anchor" href="#简介">#</a></h2><p>除了原始类型，对象是 JavaScript 最基本的数据结构。TypeScript 对于对象类型有很多规则。</p><p>对象类型的最简单声明方法，就是使用大括号表示对象，在大括号内部声明每个属性和方法的类型。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:{
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> };
</code></pre><p>上面示例中，对象<code>obj</code>的类型就写在变量名后面，使用大括号描述，内部声明每个属性的属性名和类型。</p><p>属性的类型可以用分号结尾，也可以用逗号结尾。</p><pre class="hljs"><code><span class="hljs-comment">// 属性类型以分号结尾</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
};

<span class="hljs-comment">// 属性类型以逗号结尾</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>,
};
</code></pre><p>最后一个属性后面，可以写分号或逗号，也可以不写。</p><p>一旦声明了类型，对象赋值时，就不能缺少指定的属性，也不能有多余的属性。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">o1</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">o2</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>o1</code>缺少了属性<code>y</code>，变量<code>o2</code>多出了属性<code>z</code>，都会报错。</p><p>读写不存在的属性也会报错。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:{
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> };

<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(obj.<span class="hljs-property">z</span>); <span class="hljs-comment">// 报错</span>
obj.<span class="hljs-property">z</span> = <span class="hljs-number">1</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，读写不存在的属性<code>z</code>都会报错。</p><p>同样地，也不能删除类型声明中存在的属性，修改属性值是可以的。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> myUser = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sabrina&quot;</span>,
};

<span class="hljs-keyword">delete</span> myUser.<span class="hljs-property">name</span> <span class="hljs-comment">// 报错</span>
myUser.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Cynthia&quot;</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面声明中，删除类型声明中存在的属性<code>name</code>会报错，但是可以修改它的值。</p><p>对象的方法使用函数类型描述。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:{
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-title function_">add</span>(<span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>): <span class="hljs-built_in">number</span>;
  <span class="hljs-comment">// 或者写成</span>
  <span class="hljs-comment">// add: (x:number, y:number) =&gt; number;</span>
} = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>,
  <span class="hljs-title function_">add</span>(<span class="hljs-params">x, y</span>) {
    <span class="hljs-keyword">return</span> x + y;
  }
};
</code></pre><p>上面示例中，对象<code>obj</code>有一个方法<code>add()</code>，需要定义它的参数类型和返回值类型。</p><p>对象类型可以使用方括号读取属性的类型。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
};
<span class="hljs-keyword">type</span> <span class="hljs-title class_">Name</span> = <span class="hljs-title class_">User</span>[<span class="hljs-string">&#x27;name&#x27;</span>]; <span class="hljs-comment">// string</span>
</code></pre><p>上面示例中，对象类型<code>User</code>使用方括号，读取了属性<code>name</code>的类型（<code>string</code>）。</p><p>除了<code>type</code>命令可以为对象类型声明一个别名，TypeScript 还提供了<code>interface</code>命令，可以把对象类型提炼为一个接口。</p><pre class="hljs"><code><span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> };

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyObj</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">1</span> };
</code></pre><p>上面示例中，写法一是<code>type</code>命令的用法，写法二是<code>interface</code>命令的用法。<code>interface</code>命令的详细解释，以及与<code>type</code>命令的区别，详见《Interface》一章。</p><p>注意，TypeScript 不区分对象自身的属性和继承的属性，一律视为对象的属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> {
  <span class="hljs-title function_">toString</span>(): <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 继承的属性</span>
  <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>; <span class="hljs-comment">// 自身的属性</span>
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyInterface</span> = { <span class="hljs-comment">// 正确</span>
  <span class="hljs-attr">prop</span>: <span class="hljs-number">123</span>,
};
</code></pre><p>上面示例中，<code>obj</code>只写了<code>prop</code>属性，但是不报错。因为它可以继承原型上面的<code>toString()</code>方法。</p><h2 id="可选属性">可选属性 <a class="markdownIt-Anchor" href="#可选属性">#</a></h2><p>如果某个属性是可选的（即可以忽略），需要在属性名后面加一个问号。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  y?: <span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };
</code></pre><p>上面示例中，属性<code>y</code>是可选的。</p><p>可选属性等同于允许赋值为<code>undefined</code>，下面两种写法是等效的。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;
  lastName?: <span class="hljs-built_in">string</span>;
};

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">User</span> = {
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;
  lastName?: <span class="hljs-built_in">string</span>|<span class="hljs-literal">undefined</span>;
};
</code></pre><p>上面示例中，类型<code>User</code>的可选属性<code>lastName</code>可以是字符串，也可以是<code>undefined</code>，即可选属性可以赋值为<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  y?: <span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-literal">undefined</span> };
</code></pre><p>上面示例中，可选属性<code>y</code>赋值为<code>undefined</code>，不会报错。</p><p>同样地，读取一个没有赋值的可选属性时，返回<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>,
  y?: <span class="hljs-built_in">string</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyObj</span> = { <span class="hljs-attr">x</span>: <span class="hljs-string">&#x27;hello&#x27;</span> };
obj.<span class="hljs-property">y</span>.<span class="hljs-title function_">toLowerCase</span>() <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，最后一行会报错，因为<code>obj.y</code>返回<code>undefined</code>，无法对其调用<code>toLowerCase()</code>。</p><p>所以，读取可选属性之前，必须检查一下是否为<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">user</span>:{
  <span class="hljs-attr">firstName</span>: <span class="hljs-built_in">string</span>;
  lastName?: <span class="hljs-built_in">string</span>;
} = { <span class="hljs-attr">firstName</span>: <span class="hljs-string">&#x27;Foo&#x27;</span>};

<span class="hljs-keyword">if</span> (user.<span class="hljs-property">lastName</span> !== <span class="hljs-literal">undefined</span>) {
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`hello <span class="hljs-subst">${user.firstName}</span> <span class="hljs-subst">${user.lastName}</span>`</span>)
}
</code></pre><p>上面示例中，<code>lastName</code>是可选属性，需要判断是否为<code>undefined</code>以后，才能使用。建议使用下面的写法。</p><pre class="hljs"><code><span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">let</span> firstName = (user.<span class="hljs-property">firstName</span> === <span class="hljs-literal">undefined</span>)
  ? <span class="hljs-string">&#x27;Foo&#x27;</span> : user.<span class="hljs-property">firstName</span>;
<span class="hljs-keyword">let</span> lastName = (user.<span class="hljs-property">lastName</span> === <span class="hljs-literal">undefined</span>)
  ? <span class="hljs-string">&#x27;Bar&#x27;</span> : user.<span class="hljs-property">lastName</span>;

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">let</span> firstName = user.<span class="hljs-property">firstName</span> ?? <span class="hljs-string">&#x27;Foo&#x27;</span>;
<span class="hljs-keyword">let</span> lastName = user.<span class="hljs-property">lastName</span> ?? <span class="hljs-string">&#x27;Bar&#x27;</span>;
</code></pre><p>上面示例中，写法一使用三元运算符<code>?:</code>，判断是否为<code>undefined</code>，并设置默认值。写法二使用 Null 判断运算符<code>??</code>，与写法一的作用完全相同。</p><p>TypeScript 提供编译设置<code>ExactOptionalPropertyTypes</code>，只要同时打开这个设置和<code>strictNullChecks</code>，可选属性就不能设为<code>undefined</code>。</p><pre class="hljs"><code><span class="hljs-comment">// 打开 ExactOptionsPropertyTypes 和 strictNullChecks</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>: {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  y?: <span class="hljs-built_in">number</span>;
} = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-literal">undefined</span> }; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，打开了这两个设置以后，可选属性就不能设为<code>undefined</code>了。</p><p>注意，可选属性与允许设为<code>undefined</code>的必选属性是不等价的。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = { <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, y?:<span class="hljs-built_in">number</span> };
<span class="hljs-keyword">type</span> B = { <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>, <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>|<span class="hljs-literal">undefined</span> };

<span class="hljs-keyword">const</span> <span class="hljs-title class_">ObjA</span>:A = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-title class_">ObjB</span>:B = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> }; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，属性<code>y</code>如果是一个可选属性，那就可以省略不写；如果是允许设为<code>undefined</code>的必选属性，一旦省略就会报错，必须显式写成<code>{ x: 1, y: undefined }</code>。</p><h2 id="只读属性">只读属性 <a class="markdownIt-Anchor" href="#只读属性">#</a></h2><p>属性名前面加上<code>readonly</code>关键字，表示这个属性是只读属性，不能修改。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyInterface</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">prop</span>: <span class="hljs-built_in">number</span>;
}
</code></pre><p>上面示例中，<code>prop</code>属性是只读属性，不能修改它的值。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">person</span>:{
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
} = { <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> };

person.<span class="hljs-property">age</span> = <span class="hljs-number">21</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，最后一行修改了只读属性<code>age</code>，就报错了。</p><p>只读属性只能在对象初始化期间赋值，此后就不能修改该属性。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Point</span> = {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>:<span class="hljs-title class_">Point</span> = { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> };

p.<span class="hljs-property">x</span> = <span class="hljs-number">100</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，类型<code>Point</code>的属性<code>x</code>和<code>y</code>都带有修饰符<code>readonly</code>，表示这两个属性只能在初始化期间赋值，后面再修改就会报错。</p><p>注意，如果属性值是一个对象，<code>readonly</code>修饰符并不禁止修改该对象的属性，只是禁止完全替换掉该对象。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Home</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">resident</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
    <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>
  };
}

<span class="hljs-keyword">const</span> <span class="hljs-attr">h</span>:<span class="hljs-title class_">Home</span> = {
  <span class="hljs-attr">resident</span>: {
    <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vicky&#x27;</span>,
    <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>
  }
};

h.<span class="hljs-property">resident</span>.<span class="hljs-property">age</span> = <span class="hljs-number">32</span>; <span class="hljs-comment">// 正确</span>
h.<span class="hljs-property">resident</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Kate&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">23</span> 
} <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>h.resident</code>是只读属性，它的值是一个对象。修改这个对象的<code>age</code>属性是可以的，但是整个替换掉<code>h.resident</code>属性会报错。</p><p>另一个需要注意的地方是，如果一个对象有两个引用，即两个变量对应同一个对象，其中一个变量是可写的，另一个变量是只读的，那么从可写变量修改属性，会影响到只读变量。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Person</span> {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">interface</span> <span class="hljs-title class_">ReadonlyPerson</span> {
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-keyword">readonly</span> <span class="hljs-attr">age</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">let</span> <span class="hljs-attr">w</span>:<span class="hljs-title class_">Person</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;Vicky&#x27;</span>,
  <span class="hljs-attr">age</span>: <span class="hljs-number">42</span>,
};

<span class="hljs-keyword">let</span> <span class="hljs-attr">r</span>:<span class="hljs-title class_">ReadonlyPerson</span> = w;

w.<span class="hljs-property">age</span> += <span class="hljs-number">1</span>;
r.<span class="hljs-property">age</span> <span class="hljs-comment">// 43</span>
</code></pre><p>上面示例中，变量<code>w</code>和<code>r</code>指向同一个对象，其中<code>w</code>是可写的，<code>r</code>是只读的。那么，对<code>w</code>的属性修改，会影响到<code>r</code>。</p><p>如果希望属性值是只读的，除了声明时加上<code>readonly</code>关键字，还有一种方法，就是在赋值时，在对象后面加上只读断言<code>as const</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> myUser = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sabrina&quot;</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;

myUser.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Cynthia&quot;</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，对象后面加了只读断言<code>as const</code>，就变成只读对象了，不能修改属性了。</p><p>注意，上面的<code>as const</code>属于 TypeScript 的类型推断，如果变量明确地声明了类型，那么 TypeScript 会以声明的类型为准。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">myUser</span>:{ <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span> } = {
  <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;Sabrina&quot;</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;

myUser.<span class="hljs-property">name</span> = <span class="hljs-string">&quot;Cynthia&quot;</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，根据变量<code>myUser</code>的类型声明，<code>name</code>不是只读属性，但是赋值时又使用只读断言<code>as const</code>。这时会以声明的类型为准，因为<code>name</code>属性可以修改。</p><h2 id="属性名的索引类型">属性名的索引类型 <a class="markdownIt-Anchor" href="#属性名的索引类型">#</a></h2><p>如果对象的属性非常多，一个个声明类型就很麻烦，而且有些时候，无法事前知道对象会有多少属性，比如外部 API 返回的对象。这时 TypeScript 允许采用属性名表达式的写法来描述类型，称为“属性名的索引类型”。</p><p>索引类型里面，最常见的就是属性名的字符串索引。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  [<span class="hljs-attr">property</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">foo</span>: <span class="hljs-string">&#x27;a&#x27;</span>,
  <span class="hljs-attr">bar</span>: <span class="hljs-string">&#x27;b&#x27;</span>,
  <span class="hljs-attr">baz</span>: <span class="hljs-string">&#x27;c&#x27;</span>,
};
</code></pre><p>上面示例中，类型<code>MyObj</code>的属性名类型就采用了表达式形式，写在方括号里面。<code>[property: string]</code>的<code>property</code>表示属性名，这个是可以随便起的，它的类型是<code>string</code>，即属性名类型为<code>string</code>。也就是说，不管这个对象有多少属性，只要属性名为字符串，且属性值也是字符串，就符合这个类型声明。</p><p>JavaScript 对象的属性名（即上例的<code>property</code>）的类型有三种可能，除了上例的<code>string</code>，还有<code>number</code>和<code>symbol</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T1</span> = {
  [<span class="hljs-attr">property</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">string</span>
};

<span class="hljs-keyword">type</span> <span class="hljs-variable constant_">T2</span> = {
  [<span class="hljs-attr">property</span>: <span class="hljs-built_in">symbol</span>]: <span class="hljs-built_in">string</span>
};
</code></pre><p>上面示例中，对象属性名的类型分别为<code>number</code>和<code>symbol</code>。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyArr</span> = {
  [<span class="hljs-attr">n</span>:<span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-title class_">MyArr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
<span class="hljs-comment">// 或者</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-title class_">MyArr</span> = {
  <span class="hljs-number">0</span>: <span class="hljs-number">1</span>,
  <span class="hljs-number">1</span>: <span class="hljs-number">2</span>,
  <span class="hljs-number">2</span>: <span class="hljs-number">3</span>,
};
</code></pre><p>上面示例中，对象类型<code>MyArr</code>的属性名是<code>[n:number]</code>，就表示它的属性名都是数值，比如<code>0</code>、<code>1</code>、<code>2</code>。</p><p>对象可以同时有多种类型的属性名索引，比如同时有数值索引和字符串索引。但是，数值索引不能与字符串索引发生冲突，必须服从后者，这是因为在 JavaScript 语言内部，所有的数值属性名都会自动转为字符串属性名。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = {
  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>]: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 报错</span>
  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}
</code></pre><p>上面示例中，类型<code>MyType</code>同时有两种属性名索引，但是数值索引与字符串索引冲突了，所以报错了。由于字符属性名的值类型是<code>string</code>，数值属性名的值类型只有同样为<code>string</code>，才不会报错。</p><p>同样地，可以既声明属性名索引，也声明具体的单个属性名。如果单个属性名不符合属性名索引的范围，两者发生冲突，就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyType</span> = {
  <span class="hljs-attr">foo</span>: <span class="hljs-built_in">boolean</span>; <span class="hljs-comment">// 报错</span>
  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">string</span>;
}
</code></pre><p>上面示例中，属性名<code>foo</code>符合属性名的字符串索引，但是两者的属性值类型不一样，所以报错了。</p><p>属性的索引类型写法，建议谨慎使用，因为属性名的声明太宽泛，约束太少。另外，属性名的数值索引不宜用来声明数组，因为采用这种方式声明数组，就不能使用各种数组方法以及<code>length</code>属性，因为类型里面没有定义这些东西。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyArr</span> = {
  [<span class="hljs-attr">n</span>:<span class="hljs-built_in">number</span>]: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">arr</span>:<span class="hljs-title class_">MyArr</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
arr.<span class="hljs-property">length</span> <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，读取<code>arr.length</code>属性会报错，因为类型<code>MyArr</code>没有这个属性。</p><h2 id="解构赋值">解构赋值 <a class="markdownIt-Anchor" href="#解构赋值">#</a></h2><p>解构赋值用于直接从对象中提取属性。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> {id, name, price} = product;
</code></pre><p>上面语句从对象<code>product</code>提取了三个属性，并声明属性名的同名变量。</p><p>解构赋值的类型写法，跟为对象声明类型是一样的。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> {id, name, price}:{
  <span class="hljs-attr">id</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  <span class="hljs-attr">price</span>: <span class="hljs-built_in">number</span>
} = product;
</code></pre><p>注意，目前没法为解构变量指定类型，因为对象解构里面的冒号，JavaScript 指定了其他用途。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> { <span class="hljs-attr">x</span>: foo, <span class="hljs-attr">y</span>: bar } = obj;

<span class="hljs-comment">// 等同于</span>
<span class="hljs-keyword">let</span> foo = obj.<span class="hljs-property">x</span>;
<span class="hljs-keyword">let</span> bar = obj.<span class="hljs-property">y</span>;
</code></pre><p>上面示例中，冒号不是表示属性<code>x</code>和<code>y</code>的类型，而是为这两个属性指定新的变量名。如果要为<code>x</code>和<code>y</code>指定类型，不得不写成下面这样。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> { <span class="hljs-attr">x</span>: foo, <span class="hljs-attr">y</span>: bar }
  : { <span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> } = obj;
</code></pre><p>这一点要特别小心，TypeScript 里面很容易搞糊涂。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">draw</span>(<span class="hljs-params">{
  shape: Shape,
  xPos: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span>,
  yPos: <span class="hljs-built_in">number</span> = <span class="hljs-number">100</span>
}</span>) {
  <span class="hljs-keyword">let</span> myShape = shape; <span class="hljs-comment">// 报错</span>
  <span class="hljs-keyword">let</span> x = xPos; <span class="hljs-comment">// 报错</span>
}
</code></pre><p>上面示例中，函数<code>draw()</code>的参数是一个对象解构，里面的冒号很像是为变量指定类型，其实是为对应的属性指定新的变量名。所以，TypeScript 就会解读成，函数体内不存在变量<code>shape</code>，而是属性<code>shape</code>的值被赋值给了变量<code>Shape</code>。</p><h2 id="结构类型原则">结构类型原则 <a class="markdownIt-Anchor" href="#结构类型原则">#</a></h2><p>只要对象 B 满足 对象 A 的结构特征，TypeScript 就认为对象 B 兼容对象 A 的类型，这称为“结构类型”原则（structural typing）。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> A = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">type</span> B = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
};
</code></pre><p>上面示例中，对象<code>A</code>只有一个属性<code>x</code>，类型为<code>number</code>。对象<code>B</code>满足这个特征，因此兼容对象<code>A</code>，只要可以使用<code>A</code>的地方，就可以使用<code>B</code>。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> B = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">A</span>:{ <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> } = B; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，<code>A</code>和<code>B</code>并不是同一个类型，但是<code>B</code>可以赋值给<code>A</code>，因为<code>B</code>满足<code>A</code>的结构特征。</p><p>根据“结构类型”原则，TypeScript 检查某个值是否符合指定类型时，并不是检查这个值的类型名（即“名义类型”），而是检查这个值的结构是否符合要求（即“结构类型”）。</p><p>TypeScript 之所以这样设计，是为了符合 JavaScript 的行为。JavaScript 并不关心对象是否严格相似，只要某个对象具有所要求的属性，就可以正确运行。</p><p>如果类型 B 可以赋值给类型 A，TypeScript 就认为 B 是 A 的子类型（subtyping），A 是 B 的父类型。子类型满足父类型的所有结构特征，同时还具有自己的特征。凡是可以使用父类型的地方，都可以使用子类型，即子类型兼容父类型。</p><p>这种设计有时会导致令人惊讶的结果。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> myObj = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>,
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">obj:myObj</span>) {
  <span class="hljs-keyword">let</span> sum = <span class="hljs-number">0</span>;

  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> n <span class="hljs-keyword">of</span> <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj)) {
    <span class="hljs-keyword">const</span> v = obj[n]; <span class="hljs-comment">// 报错</span>
    sum += <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(v);
  }

  <span class="hljs-keyword">return</span> sum;
}
</code></pre><p>上面示例中，函数<code>getSum()</code>要求传入参数的类型是<code>myObj</code>，但是实际上所有与<code>myObj</code>兼容的对象都可以传入。这会导致<code>const v = obj[n]</code>这一行报错，原因是<code>obj[n]</code>取出的属性值不一定是数值（<code>number</code>），使得变量<code>v</code>的类型被推断为<code>any</code>。如果项目设置为不允许变量类型推断为<code>any</code>，代码就会报错。写成下面这样，就不会报错。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">MyObj</span> = {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>,
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">getSum</span>(<span class="hljs-params">obj:MyObj</span>) {
  <span class="hljs-keyword">return</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(obj.<span class="hljs-property">x</span>) + <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">abs</span>(obj.<span class="hljs-property">y</span>);
}
</code></pre><p>上面示例就不会报错，因为函数体内部只使用了属性<code>x</code>和<code>y</code>，这两个属性有明确的类型声明，保证<code>obj.x</code>和<code>obj.y</code>肯定是数值。虽然与<code>MyObj</code>兼容的任何对象都可以传入函数<code>getSum()</code>，但是只要不使用其他属性，就不会有类型报错。</p><h2 id="严格字面量检查">严格字面量检查 <a class="markdownIt-Anchor" href="#严格字面量检查">#</a></h2><p>如果对象使用字面量表示，会触发 TypeScript 的严格字面量检查（strict object literal checking）。如果字面量的结构跟类型定义的不一样（比如多出了未定义的属性），就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>:{
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
} = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">1</span> <span class="hljs-comment">// 报错</span>
};
</code></pre><p>上面示例中，等号右边是一个对象的字面量，这时会触发严格字面量检查。只要有类型声明中不存在的属性（本例是<code>z</code>），就会导致报错。</p><p>如果等号右边不是字面量，而是一个变量，根据结构类型原则，是不会报错的。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> myPoint = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">z</span>: <span class="hljs-number">1</span>
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">point</span>:{
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>;
} = myPoint; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，等号右边是一个变量，就不会触发严格字面量检查，从而不报错。</p><p>TypeScript 对字面量进行严格检查的目的，主要是防止拼写错误。一般来说，字面量大多数来自手写，容易出现拼写错误，或者误用 API。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Options</span> = {
  <span class="hljs-attr">title</span>:<span class="hljs-built_in">string</span>;
  darkMode?:<span class="hljs-built_in">boolean</span>;
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Options</span> = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;我的网页&#x27;</span>,
  <span class="hljs-attr">darkmode</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 报错</span>
};
</code></pre><p>上面示例中，属性<code>darkMode</code>拼写错了，成了<code>darkmode</code>。如果没有严格字面量规则，就不会报错，因为<code>darkMode</code>是可选属性，根据结构类型原则，任何对象只要有<code>title</code>属性，都认为符合<code>Options</code>类型。</p><p>规避严格字面量检查，可以使用中间变量。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> myOptions = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;我的网页&#x27;</span>,
  <span class="hljs-attr">darkmode</span>: <span class="hljs-literal">true</span>,
};

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Options</span> = myOptions;
</code></pre><p>上面示例中，创建了一个中间变量<code>myOptions</code>，就不会触发严格字面量规则，因为这时变量<code>obj</code>的赋值，不属于直接字面量赋值。</p><p>如果你确认字面量没有错误，也可以使用类型断言规避严格字面量检查。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Options</span> = {
  <span class="hljs-attr">title</span>: <span class="hljs-string">&#x27;我的网页&#x27;</span>,
  <span class="hljs-attr">darkmode</span>: <span class="hljs-literal">true</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-title class_">Options</span>;
</code></pre><p>上面示例使用类型断言<code>as Options</code>，告诉编译器，字面量符合 Options 类型，就能规避这条规则。</p><p>如果允许字面量有多余属性，可以像下面这样在类型里面定义一个通用属性。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">x</span>: {
  <span class="hljs-attr">foo</span>: <span class="hljs-built_in">number</span>,
  [<span class="hljs-attr">x</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">any</span>
};

x = { <span class="hljs-attr">foo</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">baz</span>: <span class="hljs-number">2</span> };  <span class="hljs-comment">// Ok</span>
</code></pre><p>上面示例中，变量<code>x</code>的类型声明里面，有一个属性的字符串索引（<code>[x: string]</code>），导致任何字符串属性名都是合法的。</p><p>由于严格字面量检查，字面量对象传入函数必须很小心，不能有多余的属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>;
  <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span>;
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">computeDistance</span>(<span class="hljs-params">point: Point</span>) { <span class="hljs-comment">/*...*/</span> }

<span class="hljs-title function_">computeDistance</span>({ <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>, <span class="hljs-attr">z</span>: <span class="hljs-number">3</span> }); <span class="hljs-comment">// 报错</span>
<span class="hljs-title function_">computeDistance</span>({<span class="hljs-attr">x</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>}); <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，对象字面量传入函数<code>computeDistance()</code>时，不能有多余的属性，否则就通不过严格字面量检查。</p><p>编译器选项<code>suppressExcessPropertyErrors</code>，可以关闭多余属性检查。下面是它在 tsconfig.json 文件里面的写法。</p><pre class="hljs"><code>{
  <span class="hljs-string">&quot;compilerOptions&quot;</span>: {
    <span class="hljs-string">&quot;suppressExcessPropertyErrors&quot;</span>: <span class="hljs-literal">true</span>
  }
}
</code></pre><h2 id="最小可选属性规则">最小可选属性规则 <a class="markdownIt-Anchor" href="#最小可选属性规则">#</a></h2><p>根据“结构类型”原则，如果一个对象的所有属性都是可选的，那么其他对象跟它都是结构类似的。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Options</span> = {
  a?:<span class="hljs-built_in">number</span>;
  b?:<span class="hljs-built_in">number</span>;
  c?:<span class="hljs-built_in">number</span>;
};
</code></pre><p>上面示例中，类型<code>Options</code>的所有属性都是可选的，所以它可以是一个空对象，也就意味着任意对象都满足<code>Options</code>的结构。</p><p>为了避免这种情况，TypeScript 2.4 引入了一个“最小可选属性规则”，也称为<a href="https://www.typescriptlang.org/docs/handbook/release-notes/typescript-2-4.html#weak-type-detection" target="_blank" rel="noopener">“弱类型检测”</a>（weak type detection）。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Options</span> = {
  a?:<span class="hljs-built_in">number</span>;
  b?:<span class="hljs-built_in">number</span>;
  c?:<span class="hljs-built_in">number</span>;
};

<span class="hljs-keyword">const</span> opts = { <span class="hljs-attr">d</span>: <span class="hljs-number">123</span> };

<span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:<span class="hljs-title class_">Options</span> = opts; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，对象<code>opts</code>与类型<code>Options</code>没有共同属性，赋值给该类型的变量就会报错。</p><p>报错原因是，如果某个类型的所有属性都是可选的，那么该类型的对象必须至少存在一个可选属性，不能所有可选属性都不存在。这就叫做“最小可选属性规则”。</p><p>如果想规避这条规则，要么在类型里面增加一条索引属性（<code>[propName: string]: someType</code>），要么使用类型断言（<code>opts as Options</code>）。</p><h2 id="空对象">空对象 <a class="markdownIt-Anchor" href="#空对象">#</a></h2><p>空对象是 TypeScript 的一种特殊值，也是一种特殊类型。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> obj = {};
obj.<span class="hljs-property">prop</span> = <span class="hljs-number">123</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>obj</code>的值是一个空对象，然后对<code>obj.prop</code>赋值就会报错。</p><p>原因是这时 TypeScript 会推断变量<code>obj</code>的类型为空对象，实际执行的是下面的代码。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">obj</span>:{} = {};
</code></pre><p>空对象没有自定义属性，所以对自定义属性赋值就会报错。空对象只能使用继承的属性，即继承自原型对象<code>Object.prototype</code>的属性。</p><pre class="hljs"><code>obj.<span class="hljs-title function_">toString</span>() <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，<code>toString()</code>方法是一个继承自原型对象的方法，TypeScript 允许在空对象上使用。</p><p>回到本节开始的例子，这种写法其实在 JavaScript 很常见：先声明一个空对象，然后向空对象添加属性。但是，TypeScript 不允许动态添加属性，所以对象不能分步生成，必须生成时一次性声明所有属性。</p><pre class="hljs"><code><span class="hljs-comment">// 错误</span>
<span class="hljs-keyword">const</span> pt = {};
pt.<span class="hljs-property">x</span> = <span class="hljs-number">3</span>;
pt.<span class="hljs-property">y</span> = <span class="hljs-number">4</span>;

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> pt = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">3</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">4</span>
};
</code></pre><p>如果确实需要分步声明，一个比较好的方法是，使用扩展运算符（<code>...</code>）合成一个新对象。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> pt0 = {};
<span class="hljs-keyword">const</span> pt1 = { <span class="hljs-attr">x</span>: <span class="hljs-number">3</span> };
<span class="hljs-keyword">const</span> pt2 = { <span class="hljs-attr">y</span>: <span class="hljs-number">4</span> };

<span class="hljs-keyword">const</span> pt = {
  ...pt0, ...pt1, ...pt2
};
</code></pre><p>上面示例中，对象<code>pt</code>是三个部分合成的，这样既可以分步声明，也符合 TypeScript 静态声明的要求。</p><p>空对象作为类型，其实是<code>Object</code>类型的简写形式。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> <span class="hljs-attr">d</span>:{};
<span class="hljs-comment">// 等同于</span>
<span class="hljs-comment">// let d:Object;</span>

d = {};
d = { <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> };
d = <span class="hljs-string">&#x27;hello&#x27;</span>;
d = <span class="hljs-number">2</span>;
</code></pre><p>上面示例中，各种类型的值（除了<code>null</code>和<code>undefined</code>）都可以赋值给空对象类型，跟<code>Object</code>类型的行为是一样的。</p><p>因为<code>Object</code>可以接受各种类型的值，而空对象是<code>Object</code>类型的简写，所以它不会有严格字面量检查，赋值时总是允许多余的属性，只是不能读取这些属性。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Empty</span> { }
<span class="hljs-keyword">const</span> <span class="hljs-attr">b</span>:<span class="hljs-title class_">Empty</span> = {<span class="hljs-attr">myProp</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">anotherProp</span>: <span class="hljs-number">2</span>}; <span class="hljs-comment">// 正确</span>
b.<span class="hljs-property">myProp</span> <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>b</code>的类型是空对象，视同<code>Object</code>类型，不会有严格字面量检查，但是读取多余的属性会报错。</p><p>如果想强制使用没有任何属性的对象，可以采用下面的写法。</p><pre class="hljs"><code><span class="hljs-keyword">interface</span> <span class="hljs-title class_">WithoutProperties</span> {
  [<span class="hljs-attr">key</span>: <span class="hljs-built_in">string</span>]: <span class="hljs-built_in">never</span>;
}

<span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">a</span>:<span class="hljs-title class_">WithoutProperties</span> = { <span class="hljs-attr">prop</span>: <span class="hljs-number">1</span> };
</code></pre><p>上面的示例中，<code>[key: string]: never</code>表示字符串属性名是不存在的，因此其他对象进行赋值时就会报错。</p></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../typescript/function.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> function 函数</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../typescript/module.html">module 模块 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>分享本文 <span class="social-share"></span></p></div></div><div class="column column-right"><nav class="panel-info" style="border: 1px solid #ededed;"><p class="panel-heading" style="font-size: 1.0em;border-radius:0px;padding: 0.5em 0em;text-align: center;"><i class="fa fa-list-ul" aria-hidden="true"></i> Web前端教程</p><div class="panel-block" style="padding: 5px 0px;"><aside class="menu"><ul class="menu-list"><li><a href="/html/intro.html" target="_blank">&nbsp;HTML 教程</a></li><li><a href="/javascript/intro.html" target="_blank">&nbsp;JavaScript 教程</a></li><li><a href="/es6/intro.html" target="_blank">&nbsp;ES6 教程</a></li><li><a href="/typescript/intro.html" target="_blank">&nbsp;TypeScript 教程</a></li><!-- 
      <li><a href="/css/intro.html" target="_blank">&nbsp;CSS 教程</a></li>
   
      <li><a href="/webapi/intro.html" target="_blank">&nbsp;Web API 教程</a></li>
    --></ul></aside></div></nav></div></div></div></section><footer class="footer"><div class="container" style="max-width:1260px;"><div class="content has-text-centered"><p>V站（ViJian.com），上V站学全栈、全职兼职都能干<br><span>京ICP备13026726号-3</span></p></div></div></footer><script>var LOPPO={current_path:"typescript/object.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>\n<li><a href="#%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7">可选属性</a></li>\n<li><a href="#%E5%8F%AA%E8%AF%BB%E5%B1%9E%E6%80%A7">只读属性</a></li>\n<li><a href="#%E5%B1%9E%E6%80%A7%E5%90%8D%E7%9A%84%E7%B4%A2%E5%BC%95%E7%B1%BB%E5%9E%8B">属性名的索引类型</a></li>\n<li><a href="#%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC">解构赋值</a></li>\n<li><a href="#%E7%BB%93%E6%9E%84%E7%B1%BB%E5%9E%8B%E5%8E%9F%E5%88%99">结构类型原则</a></li>\n<li><a href="#%E4%B8%A5%E6%A0%BC%E5%AD%97%E9%9D%A2%E9%87%8F%E6%A3%80%E6%9F%A5">严格字面量检查</a></li>\n<li><a href="#%E6%9C%80%E5%B0%8F%E5%8F%AF%E9%80%89%E5%B1%9E%E6%80%A7%E8%A7%84%E5%88%99">最小可选属性规则</a></li>\n<li><a href="#%E7%A9%BA%E5%AF%B9%E8%B1%A1">空对象</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script><!--script src="../assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《TypeScript object 对象》，出自V站（ViJian.com）。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"ViJian_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script><script></script></body></html>