<!DOCTYPE html><html lang="zh-CN" prefix="og: http://ogp.me/ns#"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><title>TypeScript类型断言 - TypeScript教程 - V站前端教程</title><!-- link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" --><link rel="stylesheet" href="../assets/css/app.min.css"><link rel="stylesheet" href="https://apps.bdimg.com/libs/fontawesome/4.4.0/css/font-awesome.css"><!-- link rel="stylesheet" href="https://cdn.bootcss.com/font-awesome/4.7.0/css/font-awesome.css"--><!-- link rel="stylesheet" href="../assets/css/share.min.css" --><meta property="og:type" content="article"><meta property="og:title" content="TypeScript类型断言"><link rel="apple-touch-icon" href="../assets/icons/logo.png"><link rel="icon" type="image/png" href="../assets/icons/logo.png"><style>.nav-item-active{background-color: #fff;color:#9cba39}
      a{color:#399ab2}
      a:hover{color:#9cba39}
      .breadcrumb a{color:#399ab2}
      .breadcrumb a:hover{color:#9cba39}
      .navbar.is-light .navbar-end .navbar-link, .navbar.is-light .navbar-end>.navbar-item, 
      .navbar.is-light .navbar-start>.navbar-item:hover{color:#9cba39}
      .navbar-link, a.navbar-item:hover{color:#9cba39}
      .footer{padding:1.5rem 0;}

      .panel-info .panel-block .menu-list a.is-active, .panel-menu .panel-block .menu-list a.is-active {
        color: #fff;
        background-color: #399ab2;
      }
      .menu-list>li{background:#F9F9F9;border-bottom: 1px solid #ededed;} 
      .menu-list .menu-item-title{height: 35px;line-height: 35px;text-align: center;background-color: #EDEDED;color:#9cba39;font-weight: bold;}
      .menu-list > li > a .menu-list-title::before {
          font-weight: 700;
          content: "";
      }

      .panel-info .panel-block .menu, .panel-menu .panel-block .menu{padding:0 5px}</style></head><body><nav class="navbar is-light" role="navigation" id="navbar" aria-label="main navigation"><div class="container" style="max-width:1230px;"><div class="navbar-brand"><a href="/" class="navbar-item title has-text-grey has-text-weight-light is-5">V站 / ViJian.com</a></div><div class="navbar-menu" id="navMenu"><div class="navbar-start"><div class="navbar-item"><a class="navbar-item" href="/">首页</a></div><div class="navbar-item has-dropdown is-hoverable"><a class="navbar-link nav-item-active is-hidden-touch">教程</a><div class="navbar-dropdown"><a class="navbar-item" href="/html/intro.html">HTML 教程</a> <a class="navbar-item" href="/javascript/intro.html">JavaScript 教程</a> <a class="navbar-item" href="/es6/intro.html">ES6 教程</a> <a class="navbar-item" href="/typescript/intro.html">TypeScript 教程</a><!--   <a class="navbar-item" href="/webapi/intro.html">Web API 教程</a>
             <a class="navbar-item" href="/css/intro.html">CSS 教程</a>
       --></div></div></div><div class="navbar-end"></div></div></div></nav><section class="section main article" style="padding-top: 20px;"><div class="container" style="max-width:1260px;"><div class="columns"><div class="column" style="flex:none;width:16%"><nav class="panel-menu" style="border: 1px solid #ededed;"><p class="panel-heading" style="font-size: 1.0em;border-radius:0px;padding: 0.5em 0em;text-align: center;"><i class="fa fa-book" aria-hidden="true"></i> TypeScript教程</p><div class="panel-block" style="padding: 5px 0px;"><aside class="menu"><ul class="menu-list"><li class="menu-item-title" data="1_item">基础类型</li><li class="1_item"><a href="../typescript/intro.html">&nbsp; <span class="menu-list-title" style="width:100%">1.语言简介</span></a></li><li class="1_item"><a href="../typescript/basic.html">&nbsp; <span class="menu-list-title" style="width:100%">2.基本用法</span></a></li><li class="1_item"><a href="../typescript/any.html">&nbsp; <span class="menu-list-title" style="width:100%">3.any 类型</span></a></li><li class="1_item"><a href="../typescript/unknown.html">&nbsp; <span class="menu-list-title" style="width:100%">4.unknown 类型</span></a></li><li class="1_item"><a href="../typescript/never.html">&nbsp; <span class="menu-list-title" style="width:100%">5.never 类型</span></a></li><li class="1_item"><a href="../typescript/types.html">&nbsp; <span class="menu-list-title" style="width:100%">6.类型系统</span></a></li><li class="1_item"><a href="../typescript/array.html">&nbsp; <span class="menu-list-title" style="width:100%">7.array 数组</span></a></li><li class="1_item"><a href="../typescript/tuple.html">&nbsp; <span class="menu-list-title" style="width:100%">8.tuple 元组</span></a></li><li class="1_item"><a href="../typescript/symbol.html">&nbsp; <span class="menu-list-title" style="width:100%">9.symbol 类型</span></a></li><li class="1_item"><a href="../typescript/function.html">&nbsp; <span class="menu-list-title" style="width:100%">10.function 函数</span></a></li><li class="1_item"><a href="../typescript/object.html">&nbsp; <span class="menu-list-title" style="width:100%">11.object 对象</span></a></li><li class="1_item"><a href="../typescript/module.html">&nbsp; <span class="menu-list-title" style="width:100%">12.module 模块</span></a></li><li class="menu-item-title" data="2_item">面向对象</li><li class="2_item"><a href="../typescript/interface.html">&nbsp; <span class="menu-list-title" style="width:100%">1.interface 接口</span></a></li><li class="2_item"><a href="../typescript/class.html">&nbsp; <span class="menu-list-title" style="width:100%">2.class 类型</span></a></li><li class="2_item"><a href="../typescript/generics.html">&nbsp; <span class="menu-list-title" style="width:100%">3.generics 泛型</span></a></li><li class="2_item"><a href="../typescript/enum.html">&nbsp; <span class="menu-list-title" style="width:100%">4.enum 枚举</span></a></li><li class="2_item"><a href="../typescript/namespace.html">&nbsp; <span class="menu-list-title" style="width:100%">5.namespace 命名空间</span></a></li><li class="2_item"><a href="../typescript/decorator-legacy.html">&nbsp; <span class="menu-list-title" style="width:100%">6.旧装饰器</span></a></li><li class="2_item"><a href="../typescript/decorator.html">&nbsp; <span class="menu-list-title" style="width:100%">7.decorator 装饰器</span></a></li><li class="menu-item-title" data="3_item">类型操作</li><li class="3_item"><a href="../typescript/assert.html" class="is-active">&nbsp; <span class="menu-list-title" style="width:100%">1.类型断言</span></a></li><li class="3_item"><a href="../typescript/d.ts.html">&nbsp; <span class="menu-list-title" style="width:100%">2.d.ts 类型声明文件</span></a></li><li class="3_item"><a href="../typescript/operator.html">&nbsp; <span class="menu-list-title" style="width:100%">3.类型运算符</span></a></li><li class="3_item"><a href="../typescript/type-operations.html">&nbsp; <span class="menu-list-title" style="width:100%">4.类型运算</span></a></li><li class="3_item"><a href="../typescript/narrowing.html">&nbsp; <span class="menu-list-title" style="width:100%">5.类型缩小</span></a></li><li class="3_item"><a href="../typescript/mapping.html">&nbsp; <span class="menu-list-title" style="width:100%">6.类型映射</span></a></li><li class="3_item"><a href="../typescript/utility.html">&nbsp; <span class="menu-list-title" style="width:100%">7.类型工具</span></a></li><li class="menu-item-title" data="4_item">其他</li><li class="4_item"><a href="../typescript/declare.html">&nbsp; <span class="menu-list-title" style="width:100%">1.declare 关键字</span></a></li><li class="4_item"><a href="../typescript/comment.html">&nbsp; <span class="menu-list-title" style="width:100%">2.注释指令</span></a></li><li class="4_item"><a href="../typescript/es6.html">&nbsp; <span class="menu-list-title" style="width:100%">3.ES6类型</span></a></li><li class="4_item"><a href="../typescript/react.html">&nbsp; <span class="menu-list-title" style="width:100%">4.React支持</span></a></li><li class="4_item"><a href="../typescript/npm.html">&nbsp; <span class="menu-list-title" style="width:100%">5.使用npm模块</span></a></li><li class="4_item"><a href="../typescript/tsc.html">&nbsp; <span class="menu-list-title" style="width:100%">6.tsc命令行编译器</span></a></li><li class="4_item"><a href="../typescript/tsconfig.json.html">&nbsp; <span class="menu-list-title" style="width:100%">7.tsconfig.json 配置文件</span></a></li></ul></aside></div></nav></div><div class="column" style="flex:none;width:68%"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="../"><span class="icon"><i class="fa fa-home"></i></span> &nbsp;V站</a></li><li><a href="../typescript/intro.html">TypeScript教程</a></li><li><a href="../typescript/assert.html">TypeScript 类型断言</a></li></ul></nav><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../typescript/decorator.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> decorator 装饰器</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../typescript/d.ts.html">d.ts 类型声明文件 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><article class="content"><h1 class="title">TypeScript 类型断言</h1><div class="page-meta"><p>V站（ViJian.com）</p></div><h2 id="简介">简介 <a class="markdownIt-Anchor" href="#简介">#</a></h2><p>对于没有类型声明的值，TypeScript 会进行类型推断，很多时候得到的结果，未必是开发者想要的。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> T = <span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>|<span class="hljs-string">&#x27;c&#x27;</span>;
<span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;a&#x27;</span>;

<span class="hljs-keyword">let</span> <span class="hljs-attr">bar</span>:T = foo; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，最后一行报错，原因是 TypeScript 推断变量<code>foo</code>的类型是<code>string</code>，而变量<code>bar</code>的类型是<code>'a'|'b'|'c'</code>，前者是后者的父类型。父类型不能赋值给子类型，所以就报错了。</p><p>TypeScript 提供了“类型断言”这样一种手段，允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型。TypeScript 一旦发现存在类型断言，就不再对该值进行类型推断，而是直接采用断言给出的类型。</p><p>这种做法的实质是，允许开发者在某个位置“绕过”编译器的类型推断，让本来通不过类型检查的代码能够通过，避免编译器报错。这样虽然削弱了 TypeScript 类型系统的严格性，但是为开发者带来了方便，毕竟开发者比编译器更了解自己的代码。</p><p>回到上面的例子，解决方法就是进行类型断言，在赋值时断言变量<code>foo</code>的类型。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> T = <span class="hljs-string">&#x27;a&#x27;</span>|<span class="hljs-string">&#x27;b&#x27;</span>|<span class="hljs-string">&#x27;c&#x27;</span>;

<span class="hljs-keyword">let</span> foo = <span class="hljs-string">&#x27;a&#x27;</span>;
<span class="hljs-keyword">let</span> <span class="hljs-attr">bar</span>:T = foo <span class="hljs-keyword">as</span> T; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，最后一行的<code>foo as T</code>表示告诉编译器，变量<code>foo</code>的类型断言为<code>T</code>，所以这一行不再需要类型推断了，编译器直接把<code>foo</code>的类型当作<code>T</code>，就不会报错了。</p><p>总之，类型断言并不是真的改变一个值的类型，而是提示编译器，应该如何处理这个值。</p><p>类型断言有两种语法。</p><pre class="hljs"><code><span class="hljs-comment">// 语法一：&lt;类型&gt;值</span>
&lt;<span class="hljs-title class_">Type</span>&gt;value

<span class="hljs-comment">// 语法二：值 as 类型</span>
value <span class="hljs-keyword">as</span> <span class="hljs-title class_">Type</span>
</code></pre><p>上面两种语法是等价的，<code>value</code>表示值，<code>Type</code>表示类型。早期只有语法一，后来因为 TypeScript 开始支持 React 的 JSX 语法（尖括号表示 HTML 元素），为了避免两者冲突，就引入了语法二。目前，推荐使用语法二。</p><pre class="hljs"><code><span class="hljs-comment">// 语法一</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">bar</span>:T = &lt;T&gt;foo;

<span class="hljs-comment">// 语法二</span>
<span class="hljs-keyword">let</span> <span class="hljs-attr">bar</span>:T = foo <span class="hljs-keyword">as</span> T;
</code></pre><p>上面示例是两种类型断言的语法，其中的语法一因为跟 JSX 语法冲突，使用时必须关闭 TypeScript 的 React 支持，否则会无法识别。由于这个原因，现在一般都使用语法二。</p><p>下面看一个例子。《对象》一章提到过，对象类型有严格字面量检查，如果存在额外的属性会报错。</p><pre class="hljs"><code><span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">p</span>:{ <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> } = { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> };
</code></pre><p>上面示例中，等号右侧是一个对象字面量，多出了属性<code>y</code>，导致报错。解决方法就是使用类型断言，可以用两种不同的断言。</p><pre class="hljs"><code><span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">p0</span>:{ <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> } =
  { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> } <span class="hljs-keyword">as</span> { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> };

<span class="hljs-comment">// 正确</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">p1</span>:{ <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span> } =
  { <span class="hljs-attr">x</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">y</span>: <span class="hljs-number">0</span> } <span class="hljs-keyword">as</span> { <span class="hljs-attr">x</span>: <span class="hljs-built_in">number</span>; <span class="hljs-attr">y</span>: <span class="hljs-built_in">number</span> };
</code></pre><p>上面示例中，两种类型断言都是正确的。第一种断言将类型改成与等号左边一致，第二种断言使得等号右边的类型是左边类型的子类型，子类型可以赋值给父类型，同时因为存在类型断言，就没有严格字面量检查了，所以不报错。</p><p>下面是一个网页编程的实际例子。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> username = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;username&#x27;</span>);

<span class="hljs-keyword">if</span> (username) {
  (username <span class="hljs-keyword">as</span> <span class="hljs-title class_">HTMLInputElement</span>).<span class="hljs-property">value</span>; <span class="hljs-comment">// 正确</span>
}
</code></pre><p>上面示例中，变量<code>username</code>的类型是<code>HTMLElement | null</code>，排除了<code>null</code>的情况以后，HTMLElement 类型是没有<code>value</code>属性的。如果<code>username</code>是一个输入框，那么就可以通过类型断言，将它的类型改成<code>HTMLInputElement</code>，就可以读取<code>value</code>属性。</p><p>注意，上例的类型断言的圆括号是必需的，否则<code>username</code>会被断言成<code>HTMLInputElement.value</code>，从而报错。</p><p>类型断言不应滥用，因为它改变了 TypeScript 的类型检查，很可能埋下错误的隐患。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">data</span>:<span class="hljs-built_in">object</span> = {
  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">b</span>: <span class="hljs-number">2</span>,
  <span class="hljs-attr">c</span>: <span class="hljs-number">3</span>
};

data.<span class="hljs-property">length</span>; <span class="hljs-comment">// 报错</span>

(data <span class="hljs-keyword">as</span> <span class="hljs-title class_">Array</span>&lt;<span class="hljs-built_in">string</span>&gt;).<span class="hljs-property">length</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，变量<code>data</code>是一个对象，没有<code>length</code>属性。但是通过类型断言，可以将它的类型断言为数组，这样使用<code>length</code>属性就能通过类型检查。但是，编译后的代码在运行时依然会报错，所以类型断言可以让错误的代码通过编译。</p><p>类型断言的一大用处是，指定 unknown 类型的变量的具体类型。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">value</span>:<span class="hljs-built_in">unknown</span> = <span class="hljs-string">&#x27;Hello World&#x27;</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">s1</span>:<span class="hljs-built_in">string</span> = value; <span class="hljs-comment">// 报错</span>
<span class="hljs-keyword">const</span> <span class="hljs-attr">s2</span>:<span class="hljs-built_in">string</span> = value <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，unknown 类型的变量<code>value</code>不能直接赋值给其他类型的变量，但是可以将它断言为其他类型，这样就可以赋值给别的变量了。</p><p>另外，类型断言也适合指定联合类型的值的具体类型。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> <span class="hljs-attr">s1</span>:<span class="hljs-built_in">number</span>|<span class="hljs-built_in">string</span> = <span class="hljs-string">&#x27;hello&#x27;</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">s2</span>:<span class="hljs-built_in">number</span> = s1 <span class="hljs-keyword">as</span> <span class="hljs-built_in">number</span>;
</code></pre><p>上面示例中，变量<code>s1</code>是联合类型，可以断言其为联合类型里面的一种具体类型，再将其赋值给变量<code>s2</code>。</p><h2 id="类型断言的条件">类型断言的条件 <a class="markdownIt-Anchor" href="#类型断言的条件">#</a></h2><p>类型断言并不意味着，可以把某个值断言为任意类型。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> n = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">m</span>:<span class="hljs-built_in">string</span> = n <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>n</code>是数值，无法把它断言成字符串，TypeScript 会报错。</p><p>类型断言的使用前提是，值的实际类型与断言的类型必须满足一个条件。</p><pre class="hljs"><code>expr <span class="hljs-keyword">as</span> T
</code></pre><p>上面代码中，<code>expr</code>是实际的值，<code>T</code>是类型断言，它们必须满足下面的条件：<code>expr</code>是<code>T</code>的子类型，或者<code>T</code>是<code>expr</code>的子类型。</p><p>也就是说，类型断言要求实际的类型与断言的类型兼容，实际类型可以断言为一个更加宽泛的类型（父类型），也可以断言为一个更加精确的类型（子类型），但不能断言为一个完全无关的类型。</p><p>但是，如果真的要断言成一个完全无关的类型，也是可以做到的。那就是连续进行两次类型断言，先断言成 unknown 类型或 any 类型，然后再断言为目标类型。因为<code>any</code>类型和<code>unknown</code>类型是所有其他类型的父类型，所以可以作为两种完全无关的类型的中介。</p><pre class="hljs"><code><span class="hljs-comment">// 或者写成 &lt;T&gt;&lt;unknown&gt;expr</span>
expr <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> T
</code></pre><p>上面代码中，<code>expr</code>连续进行了两次类型断言，第一次断言为<code>unknown</code>类型，第二次断言为<code>T</code>类型。这样的话，<code>expr</code>就可以断言成任意类型<code>T</code>，而不报错。</p><p>下面是本小节开头那个例子的改写。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> n = <span class="hljs-number">1</span>;
<span class="hljs-keyword">const</span> <span class="hljs-attr">m</span>:<span class="hljs-built_in">string</span> = n <span class="hljs-keyword">as</span> <span class="hljs-built_in">unknown</span> <span class="hljs-keyword">as</span> <span class="hljs-built_in">string</span>; <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，通过两次类型断言，变量<code>n</code>的类型就从数值，变成了完全无关的字符串，从而赋值时不会报错。</p><h2 id="as-const-断言">as const 断言 <a class="markdownIt-Anchor" href="#as-const-断言">#</a></h2><p>如果没有声明变量类型，let 命令声明的变量，会被类型推断为 TypeScript 内置的基本类型之一；const 命令声明的变量，则被推断为值类型常量。</p><pre class="hljs"><code><span class="hljs-comment">// 类型推断为基本类型 string</span>
<span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;JavaScript&#x27;</span>;

<span class="hljs-comment">// 类型推断为字符串 “JavaScript”</span>
<span class="hljs-keyword">const</span> s2 = <span class="hljs-string">&#x27;JavaScript&#x27;</span>;
</code></pre><p>上面示例中，变量<code>s1</code>的类型被推断为<code>string</code>，变量<code>s2</code>的类型推断为值类型<code>JavaScript</code>。后者是前者的子类型，相当于 const 命令有更强的限定作用，可以缩小变量的类型范围。</p><p>有些时候，let 变量会出现一些意想不到的报错，变更成 const 变量就能消除报错。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;JavaScript&#x27;</span>;

<span class="hljs-keyword">type</span> <span class="hljs-title class_">Lang</span> =
  |<span class="hljs-string">&#x27;JavaScript&#x27;</span>
  |<span class="hljs-string">&#x27;TypeScript&#x27;</span>
  |<span class="hljs-string">&#x27;Python&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">setLang</span>(<span class="hljs-params">language:Lang</span>) {
  <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-title function_">setLang</span>(s); <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，最后一行报错，原因是函数<code>setLang()</code>的参数<code>language</code>类型是<code>Lang</code>，这是一个联合类型。但是，传入的字符串<code>s</code>的类型被推断为<code>string</code>，属于<code>Lang</code>的父类型。父类型不能替代子类型，导致报错。</p><p>一种解决方法就是把 let 命令改成 const 命令。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> s = <span class="hljs-string">&#x27;JavaScript&#x27;</span>;
</code></pre><p>这样的话，变量<code>s</code>的类型就是值类型<code>JavaScript</code>，它是联合类型<code>Lang</code>的子类型，传入函数<code>setLang()</code>就不会报错。</p><p>另一种解决方法是使用类型断言。TypeScript 提供了一种特殊的类型断言<code>as const</code>，用于告诉编译器，推断类型时，可以将这个值推断为常量，即把 let 变量断言为 const 变量，从而把内置的基本类型变更为值类型。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;JavaScript&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
<span class="hljs-title function_">setLang</span>(s);  <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，变量<code>s</code>虽然是用 let 命令声明的，但是使用了<code>as const</code>断言以后，就等同于是用 const 命令声明的，变量<code>s</code>的类型会被推断为值类型<code>JavaScript</code>。</p><p>使用了<code>as const</code>断言以后，let 变量就不能再改变值了。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;JavaScript&#x27;</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
s = <span class="hljs-string">&#x27;Python&#x27;</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，let 命令声明的变量<code>s</code>，使用<code>as const</code>断言以后，就不能改变值了，否则报错。</p><p>注意，<code>as const</code>断言只能用于字面量，不能用于变量。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> s = <span class="hljs-string">&#x27;JavaScript&#x27;</span>;
<span class="hljs-title function_">setLang</span>(s <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>); <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>as const</code>断言用于变量<code>s</code>，就报错了。下面的写法可以更清晰地看出这一点。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> s1 = <span class="hljs-string">&#x27;JavaScript&#x27;</span>;
<span class="hljs-keyword">let</span> s2 = s1 <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>另外，<code>as const</code>也不能用于表达式。</p><pre class="hljs"><code><span class="hljs-keyword">let</span> s = (<span class="hljs-string">&#x27;Java&#x27;</span> + <span class="hljs-string">&#x27;Script&#x27;</span>) <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，<code>as const</code>用于表达式，导致报错。</p><p><code>as const</code>也可以写成前置的形式。</p><pre class="hljs"><code><span class="hljs-comment">// 后置形式</span>
expr <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>

<span class="hljs-comment">// 前置形式</span>
&lt;<span class="hljs-keyword">const</span>&gt;expr
</code></pre><p><code>as const</code>断言可以用于整个对象，也可以用于对象的单个属性，这时它的类型缩小效果是不一样的。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> v1 = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,
}; <span class="hljs-comment">// 类型是 { x: number; y: number; }</span>

<span class="hljs-keyword">const</span> v2 = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,
}; <span class="hljs-comment">// 类型是 { x: 1; y: number; }</span>

<span class="hljs-keyword">const</span> v3 = {
  <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,
  <span class="hljs-attr">y</span>: <span class="hljs-number">2</span>,
} <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>; <span class="hljs-comment">// 类型是 { readonly x: 1; readonly y: 2; }</span>
</code></pre><p>上面示例中，第二种写法是对属性<code>x</code>缩小类型，第三种写法是对整个对象缩小类型。</p><p>总之，<code>as const</code>会将字面量的类型断言为不可变类型，缩小成 TypeScript 允许的最小类型。</p><p>下面是数组的例子。</p><pre class="hljs"><code><span class="hljs-comment">// a1 的类型推断为 number[]</span>
<span class="hljs-keyword">const</span> a1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];

<span class="hljs-comment">// a2 的类型推断为 readonly [1, 2, 3]</span>
<span class="hljs-keyword">const</span> a2 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
</code></pre><p>上面示例中，数组字面量使用<code>as const</code>断言后，类型推断就变成了只读元组。</p><p>由于<code>as const</code>会将数组变成只读元组，所以很适合用于函数的 rest 参数。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span></span>) {
  <span class="hljs-keyword">return</span> x + y;
}

<span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];
<span class="hljs-keyword">const</span> total = <span class="hljs-title function_">add</span>(...nums); <span class="hljs-comment">// 报错</span>
</code></pre><p>上面示例中，变量<code>nums</code>的类型推断为<code>number[]</code>，导致使用扩展运算符<code>...</code>传入函数<code>add()</code>会报错，因为<code>add()</code>只能接受两个参数，而<code>...nums</code>并不能保证参数的个数。</p><p>事实上，对于固定参数个数的函数，如果传入的参数包含扩展运算符，那么扩展运算符只能用于元组。只有当函数定义使用了 rest 参数，扩展运算符才能用于数组。</p><p>解决方法就是使用<code>as const</code>断言，将数组变成元组。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> nums = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>] <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;
<span class="hljs-keyword">const</span> total = <span class="hljs-title function_">add</span>(...nums); <span class="hljs-comment">// 正确</span>
</code></pre><p>上面示例中，使用<code>as const</code>断言后，变量<code>nums</code>的类型会被推断为<code>readonly [1, 2]</code>，使用扩展运算符展开后，正好符合函数<code>add()</code>的参数类型。</p><p>Enum 成员也可以使用<code>as const</code>断言。</p><pre class="hljs"><code><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Foo</span> {
  X,
  Y,
}
<span class="hljs-keyword">let</span> e1 = <span class="hljs-title class_">Foo</span>.<span class="hljs-property">X</span>;            <span class="hljs-comment">// Foo</span>
<span class="hljs-keyword">let</span> e2 = <span class="hljs-title class_">Foo</span>.<span class="hljs-property">X</span> <span class="hljs-keyword">as</span> <span class="hljs-keyword">const</span>;   <span class="hljs-comment">// Foo.X</span>
</code></pre><p>上面示例中，如果不使用<code>as const</code>断言，变量<code>e1</code>的类型被推断为整个 Enum 类型；使用了<code>as const</code>断言以后，变量<code>e2</code>的类型被推断为 Enum 的某个成员，这意味着它不能变更为其他成员。</p><h2 id="非空断言">非空断言 <a class="markdownIt-Anchor" href="#非空断言">#</a></h2><p>对于那些可能为空的变量（即可能等于<code>undefined</code>或<code>null</code>），TypeScript 提供了非空断言，保证这些变量不会为空，写法是在变量名后面加上感叹号<code>!</code>。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params">x?:<span class="hljs-built_in">number</span>|<span class="hljs-literal">null</span></span>) {
  <span class="hljs-title function_">validateNumber</span>(x); <span class="hljs-comment">// 自定义函数，确保 x 是数值</span>
  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(x!.<span class="hljs-title function_">toFixed</span>());
}

<span class="hljs-keyword">function</span> <span class="hljs-title function_">validateNumber</span>(<span class="hljs-params">e?:<span class="hljs-built_in">number</span>|<span class="hljs-literal">null</span></span>) {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> e !== <span class="hljs-string">&#x27;number&#x27;</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Not a number&#x27;</span>);
}
</code></pre><p>上面示例中，函数<code>f()</code>的参数<code>x</code>的类型是<code>number|null</code>，即可能为空。如果为空，就不存在<code>x.toFixed()</code>方法，这样写会报错。但是，开发者可以确认，经过<code>validateNumber()</code>的前置检验，变量<code>x</code>肯定不会为空，这时就可以使用非空断言，为函数体内部的变量<code>x</code>加上后缀<code>!</code>，<code>x!.toFixed()</code>编译就不会报错了。</p><p>非空断言在实际编程中很有用，有时可以省去一些额外的判断。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>);

<span class="hljs-comment">// 报错</span>
root.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-comment">/* ... */</span>
});
</code></pre><p>上面示例中，<code>getElementById()</code>有可能返回空值<code>null</code>，即变量<code>root</code>可能为空，这时对它调用<code>addEventListener()</code>方法就会报错，通不过编译。但是，开发者如果可以确认<code>root</code>元素肯定会在网页中存在，这时就可以使用非空断言。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>)!;
</code></pre><p>上面示例中，<code>getElementById()</code>方法加上后缀<code>!</code>，表示这个方法肯定返回非空结果。</p><p>不过，非空断言会造成安全隐患，只有在确定一个表达式的值不为空时才能使用。比较保险的做法还是手动检查一下是否为空。</p><pre class="hljs"><code><span class="hljs-keyword">const</span> root = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;root&#x27;</span>);

<span class="hljs-keyword">if</span> (root === <span class="hljs-literal">null</span>) {
  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Unable to find DOM element #root&#x27;</span>);
}

root.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> {
  <span class="hljs-comment">/* ... */</span>
});
</code></pre><p>上面示例中，如果<code>root</code>为空会抛错，比非空断言更保险一点。</p><p>非空断言还可以用于赋值断言。TypeScript 有一个编译设置，要求类的属性必须初始化（即有初始值），如果不对属性赋值就会报错。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  <span class="hljs-attr">x</span>:<span class="hljs-built_in">number</span>; <span class="hljs-comment">// 报错</span>
  <span class="hljs-attr">y</span>:<span class="hljs-built_in">number</span>; <span class="hljs-comment">// 报错</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span></span>) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre><p>上面示例中，属性<code>x</code>和<code>y</code>会报错，因为 TypeScript 认为它们没有初始化。</p><p>这时就可以使用非空断言，表示这两个属性肯定会有值，这样就不会报错了。</p><pre class="hljs"><code><span class="hljs-keyword">class</span> <span class="hljs-title class_">Point</span> {
  x!:<span class="hljs-built_in">number</span>; <span class="hljs-comment">// 正确</span>
  y!:<span class="hljs-built_in">number</span>; <span class="hljs-comment">// 正确</span>

  <span class="hljs-title function_">constructor</span>(<span class="hljs-params">x:<span class="hljs-built_in">number</span>, y:<span class="hljs-built_in">number</span></span>) {
    <span class="hljs-comment">// ...</span>
  }
}
</code></pre><p>另外，非空断言只有在打开编译选项<code>strictNullChecks</code>时才有意义。如果不打开这个选项，编译器就不会检查某个变量是否可能为<code>undefined</code>或<code>null</code>。</p><h2 id="断言函数">断言函数 <a class="markdownIt-Anchor" href="#断言函数">#</a></h2><p>断言函数是一种特殊函数，用于保证函数参数符合某种类型。如果函数参数达不到要求，就会抛出错误，中断程序执行；如果达到要求，就不进行任何操作，让代码按照正常流程运行。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">value:<span class="hljs-built_in">unknown</span></span>):<span class="hljs-built_in">void</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;string&#x27;</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Not a string&#x27;</span>);
}
</code></pre><p>上面示例中，函数<code>isString()</code>就是一个断言函数，用来保证参数<code>value</code>是一个字符串，否则就会抛出错误，中断程序的执行。</p><p>下面是它的用法。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">toUpper</span>(<span class="hljs-params">x: <span class="hljs-built_in">string</span>|<span class="hljs-built_in">number</span></span>) {
  <span class="hljs-title function_">isString</span>(x);
  <span class="hljs-keyword">return</span> x.<span class="hljs-title function_">toUpperCase</span>();
}
</code></pre><p>上面示例中，函数<code>toUpper()</code>的参数<code>x</code>，可能是字符串，也可能是数值。但是，函数体的最后一行调用<code>toUpperCase()</code>方法，必须保证<code>x</code>是字符串，否则报错。所以，这一行前面调用断言函数<code>isString()</code>，调用以后 TypeScript 就能确定，变量<code>x</code>一定是字符串，不是数值，也就不报错了。</p><p>传统的断言函数<code>isString()</code>的写法有一个缺点，它的参数类型是<code>unknown</code>，返回值类型是<code>void</code>（即没有返回值）。单单从这样的类型声明，很难看出<code>isString()</code>是一个断言函数。</p><p>为了更清晰地表达断言函数，TypeScript 3.7 引入了新的类型写法。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">value:<span class="hljs-built_in">unknown</span></span>):asserts value is <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;string&#x27;</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Not a string&#x27;</span>);
}
</code></pre><p>上面示例中，函数<code>isString()</code>的返回值类型写成<code>asserts value is string</code>，其中<code>asserts</code>和<code>is</code>都是关键词，<code>value</code>是函数的参数名，<code>string</code>是函数参数的预期类型。它的意思是，该函数用来断言参数<code>value</code>的类型是<code>string</code>，如果达不到要求，程序就会在这里中断。</p><p>使用了断言函数的新写法以后，TypeScript 就会自动识别，只要执行了该函数，对应的变量都为断言的类型。</p><p>注意，函数返回值的断言写法，只是用来更清晰地表达函数意图，真正的检查是需要开发者自己部署的。而且，如果内部的检查与断言不一致，TypeScript 也不会报错。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">value:<span class="hljs-built_in">unknown</span></span>):asserts value is <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;number&#x27;</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Not a number&#x27;</span>);
}
</code></pre><p>上面示例中，函数的断言是参数<code>value</code>类型为字符串，但是实际上，内部检查的却是它是否为数值，如果不是就抛错。这段代码能够正常通过编译，表示 TypeScript 并不会检查断言与实际的类型检查是否一致。</p><p>另外，断言函数的<code>asserts</code>语句等同于<code>void</code>类型，所以如果返回除了<code>undefined</code>和<code>null</code>以外的值，都会报错。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">value:<span class="hljs-built_in">unknown</span></span>):asserts value is <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;string&#x27;</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Not a string&#x27;</span>);
  <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>; <span class="hljs-comment">// 报错</span>
}
</code></pre><p>上面示例中，断言函数返回了<code>true</code>，导致报错。</p><p>下面是另一个例子。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">AccessLevel</span> = <span class="hljs-string">&#x27;r&#x27;</span> | <span class="hljs-string">&#x27;w&#x27;</span> | <span class="hljs-string">&#x27;rw&#x27;</span>;

<span class="hljs-keyword">function</span> <span class="hljs-title function_">allowsReadAccess</span>(<span class="hljs-params">
  level:AccessLevel
</span>):asserts level is <span class="hljs-string">&#x27;r&#x27;</span> | <span class="hljs-string">&#x27;rw&#x27;</span> {
  <span class="hljs-keyword">if</span> (!level.<span class="hljs-title function_">includes</span>(<span class="hljs-string">&#x27;r&#x27;</span>))
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Read not allowed&#x27;</span>);
}
</code></pre><p>上面示例中，函数<code>allowsReadAccess()</code>用来断言参数<code>level</code>一定等于<code>r</code>或<code>rw</code>。</p><p>如果要断言参数非空，可以使用工具类型<code>NonNullable&lt;T&gt;</code>。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> assertIsDefined&lt;T&gt;(
  <span class="hljs-attr">value</span>:T
):asserts value is <span class="hljs-title class_">NonNullable</span>&lt;T&gt; {
  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">undefined</span> || value === <span class="hljs-literal">null</span>) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${value}</span> is not defined`</span>)
  }
}
</code></pre><p>上面示例中，工具类型<code>NonNullable&lt;T&gt;</code>对应类型<code>T</code>去除空类型后的剩余类型。</p><p>如果要将断言函数用于函数表达式，可以采用下面的写法。</p><pre class="hljs"><code><span class="hljs-comment">// 写法一</span>
<span class="hljs-keyword">const</span> assertIsNumber = (
  <span class="hljs-attr">value</span>:<span class="hljs-built_in">unknown</span>
):asserts value is <span class="hljs-built_in">number</span> =&gt; {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;number&#x27;</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Not a number&#x27;</span>);
};

<span class="hljs-comment">// 写法二</span>
<span class="hljs-keyword">type</span> <span class="hljs-title class_">AssertIsNumber</span> =
  <span class="hljs-function">(<span class="hljs-params">value:<span class="hljs-built_in">unknown</span></span>) =&gt;</span> asserts value is <span class="hljs-built_in">number</span>;

<span class="hljs-keyword">const</span> <span class="hljs-attr">assertIsNumber</span>:<span class="hljs-title class_">AssertIsNumber</span> = <span class="hljs-function">(<span class="hljs-params">value</span>) =&gt;</span> {
  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value !== <span class="hljs-string">&#x27;number&#x27;</span>)
    <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;Not a number&#x27;</span>);
};
</code></pre><p>注意，断言函数与类型保护函数（type guard）是两种不同的函数。它们的区别是，断言函数不返回值，而类型保护函数总是返回一个布尔值。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">isString</span>(<span class="hljs-params">
  value:<span class="hljs-built_in">unknown</span>
</span>):value is <span class="hljs-built_in">string</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&#x27;string&#x27;</span>;
}
</code></pre><p>上面示例就是一个类型保护函数<code>isString()</code>，作用是检查参数<code>value</code>是否为字符串。如果是的，返回<code>true</code>，否则返回<code>false</code>。该函数的返回值类型是<code>value is string</code>，其中的<code>is</code>是一个类型运算符，如果左侧的值符合右侧的类型，则返回<code>true</code>，否则返回<code>false</code>。</p><p>如果要断言某个参数保证为真（即不等于<code>false</code>、<code>undefined</code>和<code>null</code>），TypeScript 提供了断言函数的一种简写形式。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">assert</span>(<span class="hljs-params">x:<span class="hljs-built_in">unknown</span></span>):asserts x {
  <span class="hljs-comment">// ...</span>
}
</code></pre><p>上面示例中，函数<code>assert()</code>的断言部分，<code>asserts x</code>省略了谓语和宾语，表示参数<code>x</code>保证为真（<code>true</code>）。</p><p>同样的，参数为真的实际检查需要开发者自己实现。</p><pre class="hljs"><code><span class="hljs-keyword">function</span> <span class="hljs-title function_">assert</span>(<span class="hljs-params">x:<span class="hljs-built_in">unknown</span></span>):asserts x {
  <span class="hljs-keyword">if</span> (!x) {
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">`<span class="hljs-subst">${x}</span> should be a truthy value.`</span>);
  }
}
</code></pre><p>这种断言函数的简写形式，通常用来检查某个操作是否成功。</p><pre class="hljs"><code><span class="hljs-keyword">type</span> <span class="hljs-title class_">Person</span> = {
  <span class="hljs-attr">name</span>: <span class="hljs-built_in">string</span>;
  email?: <span class="hljs-built_in">string</span>;
};

<span class="hljs-keyword">function</span> <span class="hljs-title function_">loadPerson</span>(<span class="hljs-params"></span>): <span class="hljs-title class_">Person</span> | <span class="hljs-literal">null</span> {
  <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
}

<span class="hljs-keyword">let</span> person = <span class="hljs-title function_">loadPerson</span>();

<span class="hljs-keyword">function</span> <span class="hljs-title function_">assert</span>(<span class="hljs-params">
  condition: <span class="hljs-built_in">unknown</span>,
  message: <span class="hljs-built_in">string</span>
</span>):asserts condition {
  <span class="hljs-keyword">if</span> (!condition) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(message);
}

<span class="hljs-comment">// Error: Person is not defined</span>
<span class="hljs-title function_">assert</span>(person, <span class="hljs-string">&#x27;Person is not defined&#x27;</span>); 
<span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(person.<span class="hljs-property">name</span>);
</code></pre><p>上面示例中，只有<code>loadPerson()</code>返回结果为真（即操作成功），<code>assert()</code>才不会报错。</p><h2 id="参考链接">参考链接 <a class="markdownIt-Anchor" href="#参考链接">#</a></h2><ul><li><a href="https://mariusschulz.com/blog/const-assertions-in-literal-expressions-in-typescript" target="_blank" rel="noopener">Const Assertions in Literal Expressions in TypeScript</a>, Marius Schulz</li><li><a href="https://mariusschulz.com/blog/assertion-functions-in-typescript" target="_blank" rel="noopener">Assertion Functions in TypeScript</a>, Marius Schulz</li><li><a href="https://blog.logrocket.com/assertion-functions-typescript/" target="_blank" rel="noopener">Assertion functions in TypeScript</a>, Matteo Di Pirro</li></ul></article><nav class="level level-previous-next is-mobile"><!-- Left side --><div class="level-left"><p class="level-item is-narrow"><a href="../typescript/decorator.html"><span class="icon"><i class="fa fa-toggle-left"></i></span> decorator 装饰器</a></p></div><div class="level-right"><p class="level-item is-narrow"><a href="../typescript/d.ts.html">d.ts 类型声明文件 <span class="icon"><i class="fa fa-toggle-right"></i></span></a></p></div></nav><div class="page-info"><p>分享本文 <span class="social-share"></span></p></div></div><div class="column" style="flex:none;width:14%"><nav class="panel-info" style="border: 1px solid #ededed;"><p class="panel-heading" style="font-size: 1.0em;border-radius:0px;padding: 0.5em 0em;text-align: center;"><i class="fa fa-list-ul" aria-hidden="true"></i> Web前端教程</p><div class="panel-block" style="padding: 5px 0px;"><aside class="menu"><ul class="menu-list"><li><a href="/html/intro.html" target="_blank">&nbsp;HTML 教程</a></li><li><a href="/javascript/intro.html" target="_blank">&nbsp;JavaScript 教程</a></li><li><a href="/es6/intro.html" target="_blank">&nbsp;ES6 教程</a></li><li><a href="/typescript/intro.html" target="_blank">&nbsp;TypeScript 教程</a></li><!-- 
      <li><a href="/css/intro.html" target="_blank">&nbsp;CSS 教程</a></li>
   
      <li><a href="/webapi/intro.html" target="_blank">&nbsp;Web API 教程</a></li>
    --></ul></aside></div></nav></div></div></div></section><footer class="footer"><div class="container" style="max-width:1260px;"><div class="content has-text-centered"><p>V站（ViJian.com），上V站学全栈、全职兼职都能干<br><span>京ICP备13026726号-3</span></p></div></div></footer><script>var LOPPO={current_path:"typescript/assert.md",relative_root_path:"../",article_toc:'<ul class="markdownIt-TOC">\n<li><a href="#%E7%AE%80%E4%BB%8B">简介</a></li>\n<li><a href="#%E7%B1%BB%E5%9E%8B%E6%96%AD%E8%A8%80%E7%9A%84%E6%9D%A1%E4%BB%B6">类型断言的条件</a></li>\n<li><a href="#as-const-%E6%96%AD%E8%A8%80">as const 断言</a></li>\n<li><a href="#%E9%9D%9E%E7%A9%BA%E6%96%AD%E8%A8%80">非空断言</a></li>\n<li><a href="#%E6%96%AD%E8%A8%80%E5%87%BD%E6%95%B0">断言函数</a></li>\n<li><a href="#%E5%8F%82%E8%80%83%E9%93%BE%E6%8E%A5">参考链接</a></li>\n</ul>\n'}</script><script src="../assets/js/app.js"></script><!--script src="../assets/js/social-share.min.js"--><!--/script--><script>var shareDesc="我正在阅读《TypeScript 类型断言》，出自V站（ViJian.com）。",shareOpts={url:window.location.href,source:shareDesc,title:shareDesc,description:"",image:"",sites:["weibo","wechat","qq","qzone","twitter","facebook"],origin:"ViJian_com",disabled:[],wechatQrcodeTitle:"微信",wechatQrcodeHelper:"扫一下二维码，分享到微信。"};socialShare(".social-share",shareOpts)</script><script></script></body></html>